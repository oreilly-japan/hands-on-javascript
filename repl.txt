
= 学び始めるまえに

== プログラムについて

[LIST 1-1]
玄関を出る
次の交差点まで直進する
字下げしている部分を３回繰り返す
　交差点を渡る
　次の交差点まで直進する

交差点を右折する
字下げしている部分を繰り返す
　もし左側にポストがあれば、字下げしている部分を実行
　　交差点を左折する
　　繰り返しを止める
　そうでなければ、字下げしている部分を実行
　　次の交差点まで直進する

突き当りまで直進する
建物に入る

== JavaScriptについて

=== JavaScriptを始める

[LIST 1-2]
javascript:alert("hello, world")

=== JavaScriptを続ける

=== JavaScriptの価値

== Chrome DevToolsの概要を理解する

=== 起動する

=== コンソールを開く

=== JavaScriptのコードを実行する

[LIST 1-3]
> console.log("hello, world") 

[LIST 1-4]
> 40+2 

[LIST 1-5]
> let sum = 1                 // Enterだと実行されてしまうのでShift-Enterで改行
  for (let i of [2, 3, 7]) {  // for文の途中なのでEnterで改行
    sum *= i                  // for文の途中なのでEnterで改行
  }                           // Enterだと実行されてしまうのでShift-Enterで改行
  sum                         // Enterで実行

== JavaScript文法の概要を理解する

=== 各概念の関係を理解する

=== 1次元セルオートマトン

[LIST 1-6]
_ 0 0 0 1 0 0 0 _
-----------------
_[0]0             --> 0
  0[0]0           --> 0
    0[0]1         --> 1
      0[1]0       --> 0
        1[0]0     --> 1
          0[0]0   --> 0
            0[0]_ --> 0

[LIST 1-7]
_ 0 0 1 0 1 0 0 _
-----------------
_[0]0             --> 0
  0[0]1           --> 1
    0[1]0         --> 0
      1[0]1       --> 0
        0[1]0     --> 0
          1[0]0   --> 1
            0[0]_ --> 0

[LIST 1-8]
_ 0 1 0 0 0 1 0 _
-----------------
_[0]1             --> 1
  0[1]0           --> 0
    1[0]0         --> 1
      0[0]0       --> 0
        0[0]1     --> 1
          0[1]0   --> 0
            1[0]_ --> 1

[LIST 1-9]
0001000
0010100
0100010
1010101

=== セルオートマトン実装を確認する

==== index.html

[LIST 1-10]
<!doctype html>
<html>
  <head>
    /* 省略 */
  </head>
  <body>
    <div id="result"></div>
    <script type="module">
      /* 後述 */
    </script>
  </body>
</html>

[LIST 1-11]
// セルオートマトンを計算するCA1Rule90の読み込み
import { CA1Rule90 } from "./ca.js"

// セルオートマトンを画面に表示する関数を定義
function addResult(ca) {
  const result = document.getElementById("result")
  for (let i = 0; i < ca.states.length; i++) {
    const cell = document.createElement("div")
    if (ca.states[i] === "0") {
      cell.classList.add("cell", "dead")
    } else {
      cell.classList.add("cell", "live")
    }
    result.appendChild(cell)
  }
}

// CA1Rule90とaddResultを用いて、セルオートマトンを計算して表示
const ca1 = new CA1Rule90("00000000000000000000100000000000000000000")
for (let i = 0; i <= 20; i++) {
  addResult(ca1)
  ca1.next()
}

[LIST 1-12]
import { CA1Rule90 } from "./js/ca.js"

[LIST 1-13]
function addResult(ca) {
  const result = document.getElementById("result")
  for (let i = 0; i < ca.states.length; i++) {
    const cell = document.createElement("div")
    if (ca.states[i] === "0") {
      cell.classList.add("cell", "dead")
    } else {
      cell.classList.add("cell", "live")
    }
    result.appendChild(cell)
  }
}

[LIST 1-14]
function 関数名(仮引数リスト) {
  処理
}

[LIST 1-15]
const result = document.getElementById("result")

[LIST 1-16]
for (let i = 0; i < ca.states.length; i++) {
  // ...
}

[LIST 1-17]
const cell = document.createElement("div")

[LIST 1-18]
if (ca.states[i] === "0") {
  cell.classList.add("cell", "dead")
} else {
  cell.classList.add("cell", "live")
}

[LIST 1-19]
result.appendChild(cell)

[LIST 1-20]
const ca1 = new CA1Rule90("00000000000000000000100000000000000000000")
for (let i = 0; i <= 20; i++) {
  addResult(ca1)
  ca1.next()
}

==== ca.js

[LIST 1-21]
class CA1Rule90 {
  constructor(initialStates) {
    this.rule = {
      "000": "0",
      "001": "1",
      "010": "0",
      "011": "1",
      "100": "1",
      "101": "0",
      "110": "1",
      "111": "0",
    }
    this.states = initialStates
  }

  next() {
    const currentStates = `0${this.states}0`
    const nextStates = []
    for (let c = 0; c < currentStates.length - 2; c++) {
      const state = currentStates.substring(c, c+3)
      nextStates[c] = this.rule[state]
    }
    this.states = nextStates.join("")
  }
}

export { CA1Rule90 }

[LIST 1-22]
class クラス名 {
  constructor(引数リスト) {
    初期化
  }

  メソッド名(引数リスト) {
    処理
  }
}

[LIST 1-23]
const currentStates = `0${this.states}0`
const nextStates = []

[LIST 1-24]
for (let c = 0; c < currentStates.length - 2; c++) {
  const state = currentStates.substring(c, c+3)
  nextStates[c] = this.rule[state]
}

[LIST 1-25]
this.states = nextStates.join("")

[LIST 1-26]
export { CA1Rule90 }

[LIST 1-27]
import { CA1Rule90 } from "./ca.js"

== Chrome DevToolsの実践的な使い方を理解する

[LIST 1-28]
> i 
4
> ca1.states 
"00000000000000001000000010000000000000000"

[LIST 1-29]
> ca1.states = "11111111111111111111111111111111111111111" // 1が41個
"11111111111111111111111111111111111111111"
> addResult(ca1) 
undefined
> ca1.next() 
undefined

== まとめ

== 練習問題

[LIST 1-30]
new CA1({
  rule:30, 
  states:[
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
    1,
    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
  ]
})

= データを学ぶ

== データの種類

[LIST 2-1]
> "9.80665"[2] 
"8"
> 9.80665[2] 
undefined

[LIST 2-2]
> typeof null 
"object"
> typeof undefined 
"undefined"
> typeof true 
"boolean"
> typeof 42 
"number"
> typeof 42n 
"bigint"
> typeof "物質" 
"string"
> typeof Symbol("貧しき漁夫") 
"symbol"
> typeof Math 
"object"

== リテラル

== 定数

[LIST 2-3]
> (1 * 2) * 3 
6
> 1 * 1 * 3 
3

[LIST 2-4]
> const pi = 3 
undefined
> (1 * 2) * pi 
6
> 1 * 1 * pi 
3

[LIST 2-5]
> const pi = 3.14 
undefined
> (1 * 2) * pi 
6.28
> 1 * 1 * pi 
3.14

=== 識別子に利用できる文字

[LIST 2-6]
> const %&+* = "Cthulhu" 
Uncaught SyntaxError: Unexpected token '%'

[LIST 2-7]
> const abc = "abc", _A_B_C = "_A_B_C", $123 = 123, 日本語 = "日本語" 

[LIST 2-8]
> const 記号 = true 
undefined
> const 記号。 = false 
Uncaught SyntaxError: Missing initializer in const declaration

=== 識別子に利用できない語

[LIST 2-9]
await      break      case       catch      class      const      continue
debugger   default    delete     do         else       export     extends
finally    for        function   if         import     in         instanceof
new        return     super      switch     this       throw      try
typeof     var        void       while      with       yield      let
static     enum       implements package    protected  interface  private
public

[LIST 2-10]
> const default = "delinquency" 
Uncaught SyntaxError: Unexpected token 'default'

== 変数

=== 変数を宣言する

[LIST 2-11]
> let radius = 6378 

[LIST 2-12]
> let radius 

[LIST 2-13]
> radius 
undefined

=== 変数に値を代入する

[LIST 2-14]
識別子 = 値

[LIST 2-15]
> let radius 
undefined
> radius = 6378 
6378
> radius = 6378.1366 
6378.1366
> radius 
6378.1366

[LIST 2-16]
> radius = "産医師異国に向かう" 
"産医師異国に向かう"
> radius = Symbol("Can I find a trick recalling Pi easily?") 
Symbol(Can I find a trick recalling Pi easily?)

[LIST 2-17]
> radius = 6378 
6378
> radius = radius + 0.1366 
6378.1366
> radius 
6378.1366

=== 変数と定数の使い分け

== Undefined

[LIST 2-18]
> let boundless 
undefined

== Null

[LIST 2-19]
> let detectedItem = null 

== 真偽値

[LIST 2-20]
> true 
true
> false 
false

=== 論理演算子

[LIST 2-21]
> true && true 
true
> true && false 
false
> false && true 
false
> false && false 
false

[LIST 2-22]
> true || true 
true
> true || false 
true
> false || true 
true
> false || false 
false

[LIST 2-23]
> !true 
false
> !false 
true

=== 論理演算

[LIST 2-24]
(P && F) || (P && M)

[LIST 2-25]
P && (F || M)

[LIST 2-26]
M = !F

[LIST 2-27]
P && (F || !F)

[LIST 2-28]
P && true

[LIST 2-29]
P

=== 論理演算子を真偽値型以外に適用する

[LIST 2-30]
> "string" && true 
true
> true || 123 
true

[LIST 2-31]
> !0 
true
> !null 
true
> !"string" 
false

[LIST 2-32]
> !!0 
false
> !!null 
false
> !!"string" 
true

[LIST 2-33]
> 123 || true 
123

[LIST 2-34]
> true && console.log("こんにちはこんにちは") 
こんにちはこんにちは
undefined
> false && console.log("こんにちはこんにちは") 
false

=== デフォルト値の設定に論理演算子を使用する

[LIST 2-35]
> let name = prompt("名前を入力してください") || "未入力" 
undefined

[LIST 2-36]
> let promptInt = (msg) => parseInt(prompt(msg)) 
undefined
> let num = promptInt("整数を入力してください") || -9999 

[LIST 2-37]
> let num = promptInt("整数を入力してください") ?? -9999 

=== 等価演算子

==== 厳密な等価演算子

[LIST 2-38]
> 1 === 1 
true
> 1 === 2 
false
> 1 === "1" 
false
> 1 === true 
false

==== 厳密な不等価演算子

[LIST 2-39]
> 1 !== 1 
false
> 1 !== 2 
true
> 1 !== "1" 
true
> 1 !== true 
true

==== 抽象的な等価演算子

[LIST 2-40]
> 1 == 1 
true
> 1 == 2 
false
> 1 == "1" 
true
> 1 == "2" 
false
> 1 == true 
true
> 1 == false 
false

[LIST 2-41]
> null === undefined 
false
> null == undefined 
true

==== 抽象的な不等価演算子

[LIST 2-42]
> 1 != 1 
false
> 1 != 2 
true
> 1 != "1" 
false
> 1 != "2" 
true
> 1 != true 
false
> 1 != false 
true

== 数値

[LIST 2-43]
> 42 
42

[LIST 2-44]
> 299792458 
299792458
> -10911 
-10911

[LIST 2-45]
> 9.80665 
9.80665

[LIST 2-46]
> .142857 
0.142857
> 8848. 
8848

=== 指数表現

[LIST 2-47]
> 0.000000056704 
5.6704e-8

[LIST 2-48]
> typeof 5.6704e-8 
"number"
> 5.6704e-8 === 0.000000056704 
true

[LIST 2-49]
> 602000000000000000000000 
6.02e+23

[LIST 2-50]
> 6.02E23 
6.02e+23

=== 10進数以外の数

= 1 × 10@<sup>{3} + 8 × 10@<sup>{2} + 3 × 10@<sup>{1} + 6 × 10@<sup>{0} + 1 × 10@<sup>{-1} + 5 × 10@<sup>{-2}

= 3 × 8@<sup>{3} + 4 × 8@<sup>{2} + 5 × 8@<sup>{1} + 4 × 8@<sup>{0}

= 1836（10進数）

[LIST 2-51]
> 0b101010 
42
> 052 
42
> 0x2a 
42

[LIST 2-52]
> 0b101010 + 052 + 0x2a 
126

[LIST 2-53]
----------------------
 2進数 0 0 1 0 1 0 1 0
----------------------
           1 0 1 0 1 0
           ----- -----
 8進数       5     2
----------------------
       0 0 1 0 1 0 1 0
       ------- -------
16進数    2       A
----------------------

=== 数値演算

[LIST 2-54]
> 6 + 36 
42
> 49 - 7 
42
> 6 * 7 
42
> 126 / 3 
42

[LIST 2-55]
> 601 % 43 
42
> 43 * 13 + 42 
601

[LIST 2-56]
> -601 % 43 
-42
> -601 % -43 
-42

[LIST 2-57]
> 12.002 ** 3 
1728.8641440080003
> 12.002 * 12.002 * 12.002 
1728.8641440080003

[LIST 2-58]
> -42 
-42
> +42 
42

[LIST 2-59]
> -     42 
-42
> - +   42 
42
> -+-42 
-42
> 42-+-42+-+42 
42
> 42 - (+(-42)) + (-(+42)) 
42

[LIST 2-60]
> --42 
Uncaught ReferenceError: Invalid left-hand side expression in prefix operation
> - -42 
42

=== ビット演算

[LIST 2-61]
> (0b1100 & 0b1010).toString(2) 
"1000"
> (0b1100 | 0b1010).toString(2) 
"1110"
> (0b1100 ^ 0b1010).toString(2).padStart(4, "0") 
"0110"

[LIST 2-62]
> 12 & 10 
8
> (12).toString(2) 
"1100"
> (10).toString(2) 
"1010"
> (8).toString(2) 
"1000"

[LIST 2-63]
> ~5 
-6

[LIST 2-64]
   1_0000_0000_0000_0000_0000_0000_0000_0000
-)   0000_0000_0000_0000_0000_0000_0000_0110
---------------------------------------------
     1111_1111_1111_1111_1111_1111_1111_1010

[LIST 2-65]
> (0b111 << 3).toString(2) 
"111000"

[LIST 2-66]
> 0b111 
7
> 0b111 << 1 
14
> 0b111 << 2 
28
> 0b111 << 3 
56

[LIST 2-67]
> ~~0b0111_1111_1111_1111_1111_1111_1111_1111 
2147483647
> ~~0b0111_1111_1111_1111_1111_1111_1111_1111 << 1 
-2
> ~~0b1111_1111_1111_1111_1111_1111_1111_1110 
-2
> ~~0b1000_1111_1111_1111_1111_1111_1111_1111 
-1879048193
> ~~0b1000_1111_1111_1111_1111_1111_1111_1111 << 1 
536870910
> ~~0b0001_1111_1111_1111_1111_1111_1111_1110 
536870910

[LIST 2-68]
> 0b1000_1111_1111_1111_1111_1111_1111_1111 
2415919103

[LIST 2-69]
> 0b0000_0000_0000_0000_0000_0000_0001_0000 
16
> 0b0000_0000_0000_0000_0000_0000_0001_0000 >> 3 
2
> 0b0000_0000_0000_0000_0000_0000_0000_0010 
2
> ~~0b1111_1111_1111_1111_1111_1111_1110_0000 
-32
> ~~0b1111_1111_1111_1111_1111_1111_1110_0000 >> 3 
-4
> ~~0b1111_1111_1111_1111_1111_1111_1111_1100 
-4

[LIST 2-70]
> 17 >> 1 
8
> 17 >> 2 
4
> 17 >> 3 
2
> -15 >> 1 
-8
> -15 >> 2 
-4
> -15 >> 3 
-2

[LIST 2-71]
> ~~0b1111_1111_1111_1111_1111_1111_1110_0000 
-32
> ~~0b1111_1111_1111_1111_1111_1111_1110_0000 >>> 3 
536870908
> ~~0b0001_1111_1111_1111_1111_1111_1111_1100 
536870908

=== 代入演算子

[LIST 2-72]
> let sum = 13 
undefined
> sum = sum + 14 
27
> sum = sum + 15 
42
> let prod = 2 
undefined
> prod = prod * 3 
6
> prod = prod * 7 
42

[LIST 2-73]
> let sum = 13 
undefined
> sum += 14 
27
> sum += 15 
42
> let prod = 2 
undefined
> prod *= 3 
6
> prod *= 7 
42

[LIST 2-74]
> let count = 0 
undefined
> ++count 
1
> ++count 
2
> --count 
1
> count 
1

[LIST 2-75]
> let count = 0 
undefined
> count++ 
0
> count++ 
1
> count-- 
2
> count 
1

[LIST 2-76]
> let count1 = 0 
undefined
> let result1 = ++count1 
undefined
> count1 
1
> result1 
1

> let count2 = 0 
undefined
> let result2 = count2++ 
undefined
> count2 
1
> result2 
0

[LIST 2-77]
> let count1 = 0 
undefined
> ++count1 
1
> result1 = count1 
1
> count1 
1
> result1 
1

> let count2 = 0 
undefined
> result2 = count2 
0
> count2++ 
0
> count2 
1
> result2 
0

=== 関係演算子

[LIST 2-78]
> 5*8 < 6*7 
true
> 5*8 > 6*7 
false
> 5*8 <= 6*7 
true
> 5*8 >= 6*7 
false

[LIST 2-79]
> let v = 1 
undefined
> if (v => 3) { // この行が誤り 
    console.log("ここには来ないはず") 
  } else { 
    console.log("ここに来るはず") 
  } 
ここには来ないはず

[LIST 2-80]
> if (v >= 3) { // 修正 
    console.log("ここには来ないはず") 
  } else { 
    console.log("ここに来るはず") 
  } 
ここに来るはず

=== 演算子の優先順位

[LIST 2-81]
> 1 + 2**3 * 4 % 5 - -6 
9

[LIST 2-82]
> 1 + 2 * 3 
7

[LIST 2-83]
> 1 + ((2**3) * 4 % 5) - (-6) 
9

[LIST 2-84]
> 252 / 3 / 2 
42
> (252 / 3) / 2 
42
> 252 / (3 / 2) 
168

[LIST 2-85]
> 2 ** 3 ** 2 
512
> 2 ** (3 ** 2) 
512
> (2 ** 3) ** 2 
64

== 長整数

[LIST 2-86]
> 9007199254740991 + 1 
9007199254740992
> 9007199254740991 + 2 
9007199254740992
> 9007199254740991 + 1 == 9007199254740991 + 2 
true

[LIST 2-87]
> 9007199254740991n + 1n 
9007199254740992n
> 9007199254740991n + 2n 
9007199254740993n
> 9007199254740991n + 1n == 9007199254740991n + 2n 
false

[LIST 2-88]
> 6n + 36n 
42n
> 49n - 7n 
42n
> 6n * 7n 
42n
> 128n / 3n 
42n
> 601n % 43n 
42n
> 12n ** 3n 
1728n
> -42n 
-42n

== 文字列

[LIST 2-89]
> "In the beginning was the Spaghetti," 
"In the beginning was the Spaghetti,"
> 'and the Spaghetti was with God,' 
"and the Spaghetti was with God,"

[LIST 2-90]
> "and the Spaghetti was God.' 
Uncaught SyntaxError: Invalid or unexpected token

[LIST 2-91]
> 'I'm a teapot.' 
Uncaught SyntaxError: Unexpected identifier
> "I'm a teapot." 
"I'm a teapot."

[LIST 2-92]
> "He said \"I'm a teapot.\"" 
"He said "I'm a teapot.""

[LIST 2-93]
> "The apparition of these faces in the crowd:\nPetals on a wet, black bough" 
"The apparition of these faces in the crowd:
Petals on a wet, black bough"

=== 文字列を連結する

[LIST 2-94]
> "The apparition of these faces in the crowd:\n" + 
  "Petals on a wet, black bough" 
"The apparition of these faces in the crowd:
Petals on a wet, black bough"

[LIST 2-95]
> 123 + "ダー" 
"123ダー"
> "加藤" + 123 
"加藤123"

[LIST 2-96]
> "dreams come " + true 
"dreams come true"

=== 文字を取り出す

[LIST 2-97]
> "R'lyeh"[0] 
"R"
> "R'lyeh"[1] 
"'"

[LIST 2-98]
> "R'lyeh"[-1] 
undefined
> "R'lyeh"[6] 
undefined

== テンプレート

[LIST 2-99]
> `Tsathoggua` 
"Tsathoggua"

[LIST 2-100]
> `\`Thusa'` 
"`Thusa'"

=== 文字列に改行を含める

[LIST 2-101]
> `安藤様 

お世話になります、ABCDの山田と申します。 

安藤様はデベロッパーとしてWebアプリ開発のご経験をお持ちとお見受けし、表題企業の依頼によりお声がけいたしました。 
` 
"安藤様

お世話になります、ABCDの山田と申します。

安藤様はデベロッパーとしてWebアプリ開発のご経験をお持ちとお見受けし、表題企業の依頼によりお声がけいたしました。
"

[LIST 2-102]
> `安藤様\n\nお世話になります、ABCDの山田と申します。\n\n安藤様はデベロッパーとしてWebアプリ開発のご経験をお持ちとお見受けし、表題企業の依頼によりお声がけいたしました。\n` 
"安藤様

お世話になります、ABCDの山田と申します。

安藤様はデベロッパーとしてWebアプリ開発のご経験をお持ちとお見受けし、表題企業の依頼によりお声がけいたしました。
"

=== 文字列にJavaScriptの式を埋め込む

[LIST 2-103]
> const candidate = "Ando", reason = "GitHub" 
undefined
> `${candidate}様 
突然のメール失礼致します。${reason}からプロフィールを拝見してメールしております。` 
"Ando様
突然のメール失礼致します。GitHubからプロフィールを拝見してメールしております。"

[LIST 2-104]
> `3 + 6 + 9 + ... + 999 = ${333 * (3 + 999) / 2}` 
"3 + 6 + 9 + ... + 999 = 166833"

== 配列

=== 配列を作成する

[LIST 2-105]
> days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

[LIST 2-106]
> [] 
[]

[LIST 2-107]
> pourelle = ["the next", 3, days] 
(3) ["the next", 3, Array(12)]

[LIST 2-108]
> ["the next", 3, [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]] 
(3) ["the next", 3, Array(12)]

[LIST 2-109]
> ["the next", 3, ...days] 
(14) ["the next", 3, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

[LIST 2-110]
> [..."the next"] 
(8) ["t", "h", "e", " ", "n", "e", "x", "t"]

[LIST 2-111]
> [ 
    "Lorem ipsum dolor sit amet", 
    "consectetur adipiscing elit", 
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua", 
  ] 
(3) ["Lorem ipsum dolor ... agna aliqua"]

[LIST 2-112]
> ["an", , "bottle"] 
(3) ["an", empty, "bottle"]
> ["an", undefined, "bottle"] 
(3) ["an", undefined, "bottle"]

[LIST 2-113]
> [,,] 
(2) [empty × 2]

=== 配列の要素を取得する

[LIST 2-114]
> days 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> days[0] 
31
> days[1] 
28

[LIST 2-115]
> days[-1] 
undefined
> days[12] 
undefined

==== 複数の要素をまとめて取得する

[LIST 2-116]
> days 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> feb = days[1], apr = days[3], jun = days[5] 
30

[LIST 2-117]
> [jan, feb, mar] = days 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> jan 
31
> [feb, mar] 
(2) [28, 31]

[LIST 2-118]
> [,feb,,apr,,jun] = days 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> apr 
30
> [feb, jun] 
(2) [28, 30]

[LIST 2-119]
> [,,,,,, ...latterHalf] = days 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> latterHalf 
(6) [31, 31, 30, 31, 30, 31]

[LIST 2-120]
> [a=1, b=2, c=3, d=4] = [10, undefined, null] 
(3) [10, undefined, null]
> [a, b, c, d] 
(4) [10, 2, null, 4]

[LIST 2-121]
> let taki = "僕たち", mitsuha = "私たち" 
undefined
> tmp = taki 
"僕たち"
> taki = mitsuha 
"私たち"
> mitsuha = tmp 
"僕たち"

[LIST 2-122]
> let taki = "僕たち", mitsuha = "私たち" 
undefined
> [taki, mitsuha] = [mitsuha, taki] 
(2) ["私たち", "僕たち"]
> taki 
"私たち"
> mitsuha 
"僕たち"

=== 配列の要素を設定する

[LIST 2-123]
> pourelle 
(3) ["the next", 3, Array(12)]
> pourelle[0] = "The Next" 
"The Next"
> pourelle 
(3) ["The Next", 3, Array(12)]

[LIST 2-124]
> pourelle[1] = "Three" 
"Three"
> pourelle 
(3) ["The Next", "Three", Array(12)]

[LIST 2-125]
> pourelle[2][1] 
28
> pourelle[2][1] = 29 
29
> pourelle[2] 
(12) [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

[LIST 2-126]
> pourelle[3] = 2008 
2008
> pourelle 
(4) ["The Next", "Three", Array(12), 2008]
> pourelle[6] = 2011 
2011
> pourelle 
(7) ["The Next", "Three", Array(12), 2008, empty × 2, 2011]

== オブジェクト

=== オブジェクトを作成する

[LIST 2-127]
> parameters = { 
    power: "B", speed: "C", range: "D", 
    durability: "C", precision: "D", development: "C", 
  } 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> iggy = {id: 0, name: "The Fool", parameters: parameters} 
{id: 0, name: "The Fool", parameters: {…}}

[LIST 2-128]
> {id: 0, name: "The Fool", parameters} 
{id: 0, name: "The Fool", parameters: {…}}

[LIST 2-129]
> {id: 0, name: "The Fool", ...parameters} 
{id: 0, name: "The Fool", power: "B", speed: "C", range: "D", …}

[LIST 2-130]
> params = {"destructive power": "B", "development potential": "C"} 
{destructive power: "B", development potential: "C"}

[LIST 2-131]
> {["加藤" + 123]: "9段"} 
{加藤123: "9段"}

=== プロパティの値を取得する

[LIST 2-132]
> iggy 
{id: 0, name: "The Fool", parameters: {…}}
> iggy.parameters.speed 
"C"

[LIST 2-133]
> params 
{destructive power: "B", development potential: "C"}
> params["destructive power"] 
"B"

[LIST 2-134]
> iggy.params 
undefined
> iggy.params.potential 
Uncaught TypeError: Cannot read property 'potential' of undefined
    at <anonymous>:1:13

[LIST 2-135]
> iggy && iggy.params && iggy.params.potential 
undefined

[LIST 2-136]
> iggy?.params?.potential 
undefined

[LIST 2-137]
> iggy.params?.["potential"] 
undefined

=== プロパティの値をまとめて取得する

[LIST 2-138]
> ({power, development} = parameters) 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> power 
"B"
> development 
"C"

[LIST 2-139]
> {power, development} = parameters 
Uncaught SyntaxError: Unexpected token '='

[LIST 2-140]
> let {power, development} = parameters 

[LIST 2-141]
> ({power:p, development:d} = parameters) 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> p 
"B"
> d 
"C"

[LIST 2-142]
> ({power="E", development="E", ability="the world"} = parameters) 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> ability 
"the world"

[LIST 2-143]
> ({ability:a="the world"} = parameters) 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> a 
"the world"

=== 複雑な構造のオブジェクトから値をまとめて取得する

[LIST 2-144]
> ko1 = {id: 1, name: "Echoes", parameters: [ 
    {power: "E", speed: "E", range: "B"}, // ACT1 
    {power: "C", speed: "D", range: "B"}, // ACT2 
    {power: "B", speed: "B", range: "C"}, // ACT3 
  ]} 
{id: 1, name: "Echoes", parameters: Array(3)}

[LIST 2-145]
> ({name, parameters:[,{speed:speed2},{range:range3}]} = ko1) 
{id: 1, name: "Echoes", parameters: Array(3)}
> name 
"Echoes"
> speed2 
"D"
> range3 
"C"

=== プロパティに値を設定する

[LIST 2-146]
> iggy.parameters.power = "スゴイ" 
"スゴイ"
> iggy.parameters 
{power: "スゴイ", speed: "C", range: "D", durability: "C", precision: "D", …}
> params["development potential"] = "人間と同じ" 
"人間と同じ"
> params 
{destructive power: "B", development potential: "人間と同じ"}

=== プロパティの有無を確認する

[LIST 2-147]
> "name" in iggy 
true
> "power" in iggy 
false

=== プロパティを削除する

[LIST 2-148]
> delete iggy.name 
true
> "name" in iggy 
false

=== オブジェクトの同一性を比較する

[LIST 2-149]
> param1 = {power: "E", speed: "E", range: "B"} 
{power: "E", speed: "E", range: "B"}
> param2 = {power: "E", speed: "E", range: "B"} 
{power: "E", speed: "E", range: "B"}

[LIST 2-150]
> param1 == param2 
false
> param1 === param2 
false

[LIST 2-151]
> param3 = param1 
{power: "E", speed: "E", range: "B"}

[LIST 2-152]
> param1 == param3 
true
> param1 === param3 
true

[LIST 2-153]
> days1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> days2 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> days3 = days1 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> days1 === days2 
false
> days1 === days3 
true

== まとめ

== 練習問題

[LIST 2-154]
let 海にいる = true
let 糸で釣る = true
let 魚 = true
let 空を飛ぶ = true
let 鳥 = true
let 赤い = true
let 白い = true

[LIST 2-155]
let ko1 = {id: 1, name: "Echoes", parameters: [
  {power: "E", speed: "E", range: "B"}, // ACT1
  {power: "C", speed: "D", range: "B"}, // ACT2
  {power: "B", speed: "B", range: "C"}, // ACT3
]}

= 処理を学ぶ

== 構造化定理

[LIST 3-1]
> [a, b] = [7854, 2730] 
(2) [7854, 2730]
> r = a % b 
2394
> [a, b] = [b, r] 
(2) [2730, 2394]
> r = a % b 
336
> [a, b] = [b, r] 
(2) [2394, 336]
> r = a % b 
42
> [a, b] = [b, r] 
(2) [336, 42]
> r = a % b 
0
> b 
42

== 文と式

[LIST 3-2]
> let pi = 3.14 
undefined
> pi = 3.14 
3.14

[LIST 3-3]
> pi = (let PI = 3.14) 
Uncaught SyntaxError: Unexpected identifier
> pi = (PI = 3.14) 
3.14

== 処理をつなげる

=== 文をつなげる

[LIST 3-4]
> let a = 40 
  let b = 2 
  let c = a + b 
undefined
> c 
42

[LIST 3-5]
> let a = 40; 
  let b = 2; 
  let c = a + b; 

[LIST 3-6]
> constants = [3.141, 2.718] 
  [first] = constants 
Uncaught ReferenceError: first is not defined
    at <anonymous>:2:2

[LIST 3-7]
> constants = [3.141, 2.718][first] = constants 

[LIST 3-8]
> constants = [3.141, 2.718]; 
  [first] = constants 
(2) [3.141, 2.718]
> first 
3.141

[LIST 3-9]
> let a = 40; let b = 2; let c = a + b; 

=== 文をまとめる

[LIST 3-10]
> { 
    const pi = 3.14 
    console.log(`ブロックの内側: ${pi}`) 
  } 
  console.log(`ブロックの外側: ${pi}`) 
ブロックの内側: 3.14
Uncaught ReferenceError: pi is not defined
    at <anonymous>:5:27

[LIST 3-11]
> const pi = 3.14 
  { 
    const pi = 3 
  } 

[LIST 3-12]
> const pi = 3.14 
  const pi = 3 
Uncaught SyntaxError: Identifier 'pi' has already been declared

=== 式をまとめる

[LIST 3-13]
> a = 6, b = 7, c = a * 7 
42

[LIST 3-14]
> let a = 6, let b = 7, let c = a * b 
Uncaught SyntaxError: let is disallowed as a lexically bound name

== 処理を分岐する

=== if

[LIST 3-15]
if (〈条件式〉)
  〈条件が成り立つときに実行される文〉
else
  〈条件が成り立たないときに実行される文〉

[LIST 3-16]
> if (true) 
    console.log("true") 
  else 
    // false 
    ; 
true

[LIST 3-17]
if (〈条件式1〉)
  〈条件1が成り立つときに実行される文〉
else 
  if (〈条件式2〉)
    〈条件2が成り立つときに実行される文〉

[LIST 3-18]
if (〈条件式1〉)
  〈条件1が成り立つときに実行される文〉
else if (〈条件式2〉)
  〈条件2が成り立つときに実行される文〉

[LIST 3-19]
> if (false) 
    if (false) 
      console.log(1) 
  else 
    console.log(2) 

[LIST 3-20]
if (false) {
  if (false) {
    console.log(1)
  }
  else {
    console.log(2)
  }
}

[LIST 3-21]
> if (false) { 
    if (false) 
      console.log(1) 
  } 
  else { 
    console.log(2) 
  } 
2

=== switch

[LIST 3-22]
switch (〈条件式〉) {
  case 〈場合1〉:
    〈条件式の結果が場合1と一致するときの処理〉
  case 〈場合2〉:
    〈条件式の結果が場合2と一致するときの処理〉
  default:
    〈条件式の結果が場合1、2のいずれとも一致しないときの処理〉
}

[LIST 3-23]
switch (〈条件式〉) {
  case 〈場合1〉:
    〈条件式の結果が場合1と一致するときの処理〉
    break
  case 〈場合2〉:
    〈条件式の結果が場合2と一致するときの処理〉
    break
  default:
    〈条件式の結果が場合1、2のいずれとも一致しないときの処理〉
}

[LIST 3-24]
> switch (null) { 
    case undefined: 
      console.log("undefined") 
      break 
    case null: 
      console.log("null") 
  } 
null

[LIST 3-25]
> switch (1) { 
    case 1: 
      console.log("1-1") 
      break 
    case 1: 
      console.log("1-2") 
  } 
1-1

[LIST 3-26]
> switch (0) { 
    case 1: 
      console.log(1) 
      break 
    case 2: 
      console.log(2) 
      break 
    default: 
      console.log("default") 
  } 
default

=== 条件演算子

[LIST 3-27]
〈条件式〉 ? 〈条件が真のときに実行される式〉 : 〈条件が偽のときに実行される式〉

[LIST 3-28]
> let pi = true ? 3.14 : 3 
undefined
> pi 
3.14

[LIST 3-29]
> let pi 
  if (true) { 
    pi = 3.14 
  } 
  else { 
    pi = 3 
  } 
3.14
> pi 
3.14

[LIST 3-30]
> val = 0 
0
> val < 0 ? "負" : val > 0 ? "正" : "ゼロ" 
"ゼロ"

[LIST 3-31]
> val < 0 ? "負" : (val > 0 ? "正" : "ゼロ") 

[LIST 3-32]
> val < 0 ? "負" : 
  val > 0 ? "正" : 
            "ゼロ" 
"ゼロ"

== 処理を繰り返す

=== for

[LIST 3-33]
for (〈初めに一度だけ実行される初期化式〉; 〈条件式〉; 〈繰り返し後に毎回実行される処理〉)
  〈条件が満たされている間、繰り返される文〉

[LIST 3-34]
> for (let i = 0; i < 3; i++) console.log(i) 
0
1
2

[LIST 3-35]
> for (let i = 0; i <= 3; i++) console.log(i) 
0
1
2
3

[LIST 3-36]
> for (let i = 0; i < 3; i++) { 
    const j = i * 2 
    console.log(j) 
  } 
0
2
4

[LIST 3-37]
> let i = 0 
undefined
> for (;;) { 
    if (3 <= i) break 
    console.log(i) 
    i++ 
  } 
0
1
2

[LIST 3-38]
> outer: for (let i = 0; i < 3; i++) { 
    innter: for (let j = 0; j < 3; j++) { 
      console.log(`${i} * ${j} = ${i * j}`) 
      if (i * j === 2) break outer 
    } 
  } 
0 * 0 = 0
0 * 1 = 0
0 * 2 = 0
1 * 0 = 0
1 * 1 = 1
1 * 2 = 2

[LIST 3-39]
> outer: for (let i = 0; i < 3; i++) { 
    innter: for (let j = 0; j < 3; j++) { 
      console.log(`${i} * ${j} = ${i * j}`) 
      if (i * j === 2) break 
    } 
  } 
0 * 0 = 0
0 * 1 = 0
0 * 2 = 0
1 * 0 = 0
1 * 1 = 1
1 * 2 = 2
2 * 0 = 0
2 * 1 = 2

=== for-of

[LIST 3-40]
> days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> for (let i = 0; i < 12; i++) { 
    console.log(days[i]) 
  } 
31
28
31
 :

[LIST 3-41]
for (〈各要素を受け取る変数の宣言〉 of 〈配列〉)
  〈要素がある間、繰り返される文〉

[LIST 3-42]
> for (const day of days) { 
    console.log(day) 
  } 
31
28
31
 :

[LIST 3-43]
> parameters = [ 
    {power: "E", speed: "E", range: "B"}, 
    {power: "C", speed: "D", range: "B"}, 
    {power: "B", speed: "B", range: "C"}, 
  ] 
(3) [{…}, {…}, {…}]
> for (const {speed} of parameters) { 
    console.log(speed) 
  } 
E
D
B

=== for-in

[LIST 3-44]
for (〈各プロパティ名を受け取る変数の宣言〉 in 〈オブジェクト〉)
  〈プロパティがある間、繰り返される文〉

[LIST 3-45]
> parameters = { 
    power: "B", speed: "C", range: "D", 
    durability: "C", precision: "D", development: "C", 
  } 
{power: "B", speed: "C", range: "D", durability: "C", precision: "D", …}
> for (const name in parameters) { 
    console.log(`${name}: ${parameters[name]}`) 
  } 
power: B
speed: C
range: D
durability: C
precision: D
development: C

[LIST 3-46]
> days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> for (const i in days) { 
    console.log(`days[${i}] = ${days[i]}`) 
  } 
days[0] = 31
days[1] = 28
days[2] = 31
 :

=== while

[LIST 3-47]
while (〈条件式〉) 
  〈条件が満たされている間、繰り返される文〉

[LIST 3-48]
> while (false) console.log("実行されない") 
undefined

[LIST 3-49]
> while (true) ; 

[LIST 3-50]
> count = 3 
3
> while (0 < count) console.log(count--) 
3
2
1

[LIST 3-51]
> count = 3 
3
> while (0 < count) { 
    console.log(count) 
    count-- 
  } 
3
2
1

=== do ... while

[LIST 3-52]
do
  〈条件が満たされている間、繰り返される文〉
while (〈条件式〉) 

[LIST 3-53]
> do 
    console.log("実行") 
  while (false) 
実行

== 関数

[LIST 3-54]
> typeof console.log 
"function"

[LIST 3-55]
> typeof console.log() 
"undefined"

=== 関数を実行する

[LIST 3-56]
〈関数名〉(〈引数リスト〉)

=== 関数を定義する

[LIST 3-57]
function 〈関数名〉(〈仮引数リスト〉) {
  〈本文〉
}

[LIST 3-58]
〈関数名〉 = function(〈仮引数リスト〉) {
  〈本文〉
}

[LIST 3-59]
〈関数名〉 = (〈仮引数リスト〉) => {
  〈本文〉
}

[LIST 3-60]
> function getPrimes(max) { 
    let primes = "" 

  outer: 
    for (let i = 1; i < max; i++) { 
      for (let divisor = i-1; 1 < divisor; divisor--) { 
        if (i % divisor === 0) continue outer 
      } 
      primes += i + " " 
    } 

    return primes 
  } 
  getPrimes(10) 
"1 2 3 5 7 "

==== 関数名

[LIST 3-61]
> function 次の数以下の素数を取得する(最大値) { 
    let 素数リスト = "" 

  外部ループ: 
    for (let 素数候補 = 1; 素数候補 < 最大値; 素数候補++) { 
      for (let 除数 = 素数候補-1; 1 < 除数; 除数--) { 
        if (素数候補 % 除数 === 0) continue 外部ループ 
      } 
      素数リスト += 素数候補 + " " 
    } 

    return 素数リスト 
  } 
  次の数以下の素数を取得する(10) 
"1 2 3 5 7 "

==== 仮引数リスト

[LIST 3-62]
> function getAverage(n1, n2, n3) { 
    console.log(n1, n2, n3) 
    return (n1 + n2 + n3) / 3 
  } 
  getAverage(3, 48, 75) 
3 48 75
42

[LIST 3-63]
> getAverage(22, 62) 
22 62 undefined
NaN

[LIST 3-64]
> function getAverage(n1, n2, n3=100) { 
    console.log(n1, n2, n3) 
    return (n1 + n2 + n3) / 3 
  } 
  getAverage(7, 19) 
7 19 100
42

[LIST 3-65]
> getAverage(3, 48, 75, 108, 147, 192) 
3 48 75
42

[LIST 3-66]
> function getAverage(n1, n2, n3, ...ns) { 
    console.log(n1, n2, n3, ns) 
    sum = n1 + n2 + n3 
    for (n of ns) { 
      sum += n 
    } 
    return sum / (ns.length + 3) 
  } 
  getAverage(22, 32, 42, 52, 62) 
22 32 42 (2) [52, 62]
42

[LIST 3-67]
> function getAverage(...ns) { 
    console.log(ns) 
    sum = 0 
    for (n of ns) { 
      sum += n 
    } 
    return sum / ns.length 
  } 
  getAverage(22, 32, 42, 52, 62) 
(5) [22, 32, 42, 52, 62]
42

[LIST 3-68]
> function getAverage(n1, n2, ...ns, n3) {} 
Uncaught SyntaxError: Rest parameter must be last formal parameter

[LIST 3-69]
> function addVectors({x:x1, y:y1}, {x:x2, y:y2}) { 
    return {x:(x1+x2)/2, y:(y1+y2)/2} 
  } 
  addVectors({x:1, y:1}, {x:7, y:3}) 
{x: 4, y: 2}

==== 関数定義の中で関数自身を呼び出す

[LIST 3-70]
> function getFactorial(num) { 
    return num === 1 ? 1 : num * getFactorial(num - 1) 
  } 
  getFactorial(3) 
6

=== 式で関数を定義する

[LIST 3-71]
> let addVs = addVectors 
undefined
> addVs({x:1, y:1}, {x:7, y:3}) 
{x: 4, y: 2}

==== 通常の関数宣言の代わりに関数式を使用する

[LIST 3-72]
> let getAverage = function(n1, n2, n3) { 
    return (n1 + n2 + n3) / 3 
  } 
  getAverage(3, 48, 75) 
42

==== 関数式を引数として使用する

[LIST 3-73]
> function map(ary, func) { 
    for (let i in ary) { 
      ary[i] = func(ary[i]) 
    } 
    return ary 
  } 
  map([1, 4, 5], function(n) { return n * n }) 
(3) [1, 16, 25]

[LIST 3-74]
> function double(n) { 
    return n * n 
  } 
undefined
> map([1, 2, 3], double) 
(3) [1, 4, 9]

==== 関数式を戻り値として使用する

[LIST 3-75]
> function mul(m, n) { 
    return m * n 
  } 
  function mulM(m) { 
    return function(n) { 
      return mul(m, n) 
    } 
  } 
  mul6 = mulM(6) 
  mul6(7) 
42

==== 再帰関数を関数式で定義する

[LIST 3-76]
> let fact = function(num) { 
    return num === 1 ? 1 : num * fact(num - 1) 
  } 
  fact(3) 
6

==== アロー関数

[LIST 3-77]
(〈仮引数リスト〉) => {
  〈本文〉
}

[LIST 3-78]
> let fact = (num) => { 
    return num === 1 ? 1 : num * fact(num - 1) 
  } 

[LIST 3-79]
> let fact = num => num === 1 ? 1 : num * fact(num - 1) 

[LIST 3-80]
fact = num => num === 1 ? 1 : num * fact(num - 1)
fact = function(num) { return num === 1 ? 1 : num * fact(num - 1) }

[LIST 3-81]
> arrowFunc = ({a, b}, c=3, ...d) => console.log(a, b, c, d) 
  arrowFunc({a:1, b:2}, undefined, 4, 5, 6) 
1 2 3 (3) [4, 5, 6]

=== タグ関数を使用してテンプレート文字列を処理する

[LIST 3-82]
> let bold = (strs, ...targets) => { 
    let ret = strs[0] 
    for (i = 1; i < 3; i++) { 
      ret += `<b>${targets[i-1]}</b>${strs[i]}` 
    } 
    return ret 
  } 
undefined
> bold`The ${"world"} is ${"mine"}` 
"The <b>world</b> is <b>mine</b>"

[LIST 3-83]
> console.log`The ${"world"} is ${"mine"}` 
(3) ["The ", " is ", "", raw: Array(3)] "world" "mine"
undefined

[LIST 3-84]
> const raw = (strs) => [[...strs], strs.raw] 
undefined
> raw`the\tworld\tis\tmine` 
(2) [Array(1), Array(1)]
  0: ["the  world   is  mine"]
  1: ["the\tworld\tis\tmine"]
  length: 2
  __proto__: Array(0)

== エラーを処理する

=== エラーの種類

[LIST 3-85]
> for (); 
Uncaught SyntaxError: Unexpected token ')'

[LIST 3-86]
> Array(-1) 
Uncaught RangeError: Invalid array length
    at <anonymous>:1:1
(anonymous) @ VM1637:1
> notdefined 
Uncaught ReferenceError: notdefined is not defined
    at <anonymous>:1:1
> "not a function"() 
Uncaught TypeError: "not a function" is not a function
    at <anonymous>:1:17
> decodeURI("\u0025\u1234") 
Uncaught URIError: URI malformed
    at decodeURI (<anonymous>)
    at <anonymous>:1:1

[LIST 3-87]
> myError = Error("Love truth, but pardon error.") 
Error: Love truth, but pardon error.
    at <anonymous>:1:7
> myError.message 
"Love truth, but pardon error."

=== エラーを投げる

[LIST 3-88]
> throw myError 
Uncaught Error: Love truth, but pardon error.
    at <anonymous>:1:9

[LIST 3-89]
> throw 42 
Uncaught 42

[LIST 3-90]
> throw; 
Uncaught SyntaxError: Unexpected token ';'

=== エラーを捕捉する

[LIST 3-91]
try {
  〈エラーが発生する可能性のある処理〉
} catch (〈エラー〉) {
  〈例外処理〉
} finally {
  〈後処理〉
}

[LIST 3-92]
> try { 
    console.log("実行される") 
    throw Error("エラーが発生しました") 
    console.log("実行されない") 
  } catch (e) { 
    console.log(`捕捉: ${e}`) 
  } finally { 
    console.log("後処理") 
  } 
実行される
捕捉: Error: エラーが発生しました
後処理

[LIST 3-93]
> try { 
    throw {power: "E", speed: "E", range: "B"} 
  } catch({speed}) { 
    console.log(speed) 
  } 
E

[LIST 3-94]
> try { 
    throw Error("エラーが発生しました") 
  } catch ({message}) { 
    console.log(message) 
  } 
エラーが発生しました
undefined

[LIST 3-95]
> try { 
    throw Error("内容は無視") 
  } catch { 
    console.log("エラー発生") 
  } 
エラー発生

[LIST 3-96]
> try { 
    throw Error("エラーが発生しました") 
  } finally { 
    console.log("後処理") 
  } 
後処理
Uncaught Error: エラーが発生しました
    at <anonymous>:2:13
(anonymous) @ VM3561:2

[LIST 3-97]
> try { 
    try { 
      throw Error("エラー") 
    } catch (e) { 
      console.log(`内側:${e}`) 
    } 
  } catch (e) { 
      console.log(`外側:${e}`) 
  } 
内側:Error: エラー
undefined

[LIST 3-98]
> try { 
    try { 
      throw Error("エラー") 
    } catch (e) { 
      console.log(`内側:${e}`) 
      throw e 
    } 
  } catch (e) { 
    console.log(`外側:${e}`) 
  } 
内側:Error: エラー
外側:Error: エラー
undefined

[LIST 3-99]
> const innerFunc = () => { 
    try { 
      throw Error("エラー") 
    } catch (e) { 
      console.log(`内側:${e}`) 
      throw e 
    } 
  } 
undefined
> const outerFunc = () => { 
    try { 
      innerFunc() 
    } catch (e) { 
      console.log(`外側:${e}`) 
      throw e 
    } 
  } 
undefined
> outerFunc() 
内側:Error: エラー
外側:Error: エラー
Uncaught Error: エラー
    at innerFunc (<anonymous>:3:11)
    at outerFunc (<anonymous>:3:5)
    at <anonymous>:1:1

== まとめ

== 練習問題

[LIST 3-100]
if (c == 1) {
  console.log("case 1")
} else if (c == 2) {
  console.log("case 2")
} else {
  console.log("default")
  console.log("case 2")
}

[LIST 3-101]
let i = 0
while (i < 3) {
  const j = i * 2
  console.log(j)
  i++
}

[LIST 3-102]
const pow = (n, e) => {
  let result = 1
  for (let i = 0; i < e; i++) result *= n
  return result
}
const powE = e => {
  return n => pow(n, e)
}
const sumMap = (ary, f) => {
  let result = 0
  for (let n of ary) {
    result += f(n)
  }
  return result
}

[LIST 3-103]
sumMap([1, 4, 5], powE(2))

[LIST 3-104]
const func = () => {
  try {
    try {
      throw Error("[例外1]")
    } catch ({message}) {
      throw Error(`${message}[例外処理1]`)
    } finally {
      throw Error("[終了処理1]")
    }
  } catch ({message}) {
    throw Error(`${message}[例外処理2]`)
  }
}
try {
  func()
} catch ({message}) {
  throw Error(`${message}[例外処理3]`)
}

= オブジェクトを学ぶ

== オブジェクト指向

=== オブジェクトの型同士の関係

== オブジェクト指向プログラミング

[LIST 4-1]
> let vector2 = { 
    x:3, y:4, 
    lengthSq:self => self.x * self.x + self.y * self.y, 
    add:(self, other) => { 
      self.x += other.x 
      self.y += other.y 
    } 
  } 
undefined
> vector2.lengthSq(vector2) 
25

[LIST 4-2]
> const Vector2 = (x, y) => { 
    return { 
      x, y, 
      lengthSq:self => self.x * self.x + self.y * self.y, 
      add:(self, other) => { 
        self.x += other.x 
        self.y += other.y 
      } 
    } 
  } 
undefined
> vector2a = Vector2(20, 22) 
{x: 20, y: 22, lengthSq: ƒ, add: ƒ}
> vector2b = Vector2(22, 20) 
{x: 22, y: 20, lengthSq: ƒ, add: ƒ}
> vector2a.add(vector2a, vector2b) 
undefined
> vector2a 
{x: 42, y: 42, lengthSq: ƒ, add: ƒ}

[LIST 4-3]
> const Vector2_lengthSq = self => self.x * self.x + self.y * self.y 
undefined
> const Vector2_add = (self, other) => { 
    self.x += other.x 
    self.y += other.y 
  } 
undefined
> const Vector2 = (x, y) => { 
    return { x, y, lengthSq:Vector2_lengthSq, add:Vector2_add } 
  } 
undefined

[LIST 4-4]
> const Vector3_lengthSq = 
    self => self.parent.lengthSq(self) + self.z * self.z 
undefined
> const Vector3_add = (self, other) => { 
    self.parent.add(self, other) 
    self.z += other.z 
  } 
undefined
> const Vector3 = (x, y, z) => { 
    let parent = Vector2(x, y) 
    return { 
      parent, 
      ...parent, 
      z, 
      lengthSq: Vector3_lengthSq, 
      add: Vector3_add 
    } 
  } 
undefined
> vector3a = Vector3(1, 4, 5) 
{parent: {…}, x: 1, y: 4, lengthSq: ƒ, add: ƒ, …}
> vector3a.lengthSq(vector3a) 
42
> vector3b = Vector3(41, 38, 37) 
{parent: {…}, x: 41, y: 38, lengthSq: ƒ, add: ƒ, …}
> vector3a.add(vector3a, vector3b) 
undefined
> vector3a 
{parent: {…}, x: 42, y: 42, lengthSq: ƒ, add: ƒ, …}

== 関数から自身が所属するオブジェクトにアクセスする

[LIST 4-5]
> const Vector2_lengthSq = function() { 
    return this.x * this.x + this.y * this.y 
  } 
undefined
> const Vector2 = (x, y) => { 
    return { x:x, y:y, lengthSq:Vector2_lengthSq } 
  } 
undefined
> v2 = Vector2(3, 4) 
{x: 3, y: 4, lengthSq: ƒ}
> v2.lengthSq() 
25

[LIST 4-6]
> Vector2_lengthSq() 
NaN

== クラスを定義する

[LIST 4-7]
class 〈クラス名〉 {
  〈クラス定義〉
}

[LIST 4-8]
> class Vector2 { 
    constructor(x, y) { 
      this.x = x 
      this.y = y 
    } 

    lengthSq() { 
      return this.x * this.x + this.y * this.y 
    } 

    add(that) { 
      this.x += that.x 
      this.y += that.y 
    } 
  } 

[LIST 4-9]
class Vec2 {
  x = 0
  y = 0
}

=== スーパークラスを継承する

[LIST 4-10]
class 〈クラス名〉 extends 〈スーパークラス名〉 {
  〈クラス定義〉
}

[LIST 4-11]
> class Vector3 extends Vector2 { 
    constructor(x, y, z) { 
      super(x, y) 
      this.z = z 
    } 

    lengthSq() { 
      return super.lengthSq() + this.z * this.z 
    } 

    add(that) { 
      super.add(that) 
      this.z += that.z 
    } 
  } 

=== インスタンスを生成する

[LIST 4-12]
> let v3a = new Vector3(1, 4, 5) 
undefined
> v3a.lengthSq() 
42
> let v3b = new Vector3(41, 38, 37) 
undefined
> v3a.add(v3b) 
undefined
> v3a 
Vector3 {x: 42, y: 42, z: 42}

=== ゲッター／セッターを定義する

[LIST 4-13]
> class Vector2 { 
    // ...これまでのメソッドは省略... 

    get length() { 
      return Math.sqrt(this.lengthSq()) // Math.sqrt()は二乗根を返す 
    } 

    set length(len) { 
      const ratio = len / this.length 
      this.x *= ratio 
      this.y *= ratio 
    } 
  } 

[LIST 4-14]
> vec = new Vector2(3, 4) 
Vector2 {x: 3, y: 4}
> vec.length 
5
> vec.length = 50 
50
> vec 
Vector2 {x: 30, y: 40}

=== 静的メソッドを定義する

[LIST 4-15]
> class Vector2 { 
    static instanceCount = 0 

    static incrementCount() { 
      this.instanceCount++ 
    } 

    constructor(x, y) { 
      this.x = x 
      this.y = y 
      Vector2.incrementCount() 
    } 
  } 

[LIST 4-16]
> new Vector2(1, 1) 
Vector2 {x: 1, y: 1}
> Vector2.instanceCount 
1
> new Vector2(2, 2) 
Vector2 {x: 2, y: 2}
> Vector2.instanceCount 
2

=== クラスを式で定義する

[LIST 4-17]
> const Vector2 = class { 
    constructor(x, y) { 
      this.x = x; 
      this.y = y; 
    } 
  } 
undefined
> vec2 = new Vector2(3, 4) 
Vector2 {x: 3, y: 4}

[LIST 4-18]
> const Vector3 = class extends Vector2 { 
    constructor(x, y, z) { 
      super(x, y) 
      this.z = z 
    } 
  } 
undefined
> vec3 = new Vector3(1, 4, 5) 
Vector3 {x: 1, y: 4, z: 5}

== オブジェクトリテラル再び

=== メソッドを定義する

[LIST 4-19]
> let tusk = { 
    act1() { 
      console.log("Chumimin") 
    } 
  } 
undefined
> tusk.act1() 
Chumimin
undefined

[LIST 4-20]
> let tusk = { 
    cry: "Chumimin", 

    act1() { 
      console.log(this.cry) 
    }, 

    act2() { 
      this.act1() 
      console.log("Tail") 
    } 
  } 
undefined
> tusk.act2() 
Chumimin
Tail
undefined

[LIST 4-21]
> let tusk = { 
    get cry() { return "Chumimin" }, 
  } 
undefined
> tusk.cry 
"Chumimin"

=== 継承

[LIST 4-22]
> let tusk1 = { 
    cry: "Chumimin", 

    act1() { 
      console.log(this.cry) 
    } 
  } 
undefined
> let tusk2 = { 
    __proto__: tusk1, 

    act2() { 
      super.act1() 
      console.log("Tail") 
    } 
  } 
undefined
> tusk2.cry 
"Chumimin"
> tusk2.act1() 
Chumimin
undefined
> tusk2.act2() 
Chumimin
Tail
undefined

== Objectクラス

=== すべてのオブジェクトのメソッドとして利用できる機能

==== プロパティを調べる

[LIST 4-23]
> [].hasOwnProperty("hasOwnProperty") 
false
> [].hasOwnProperty("length") 
true

[LIST 4-24]
> [].hasOwnProperty("0") 
false
> [42].hasOwnProperty("0") 
true

[LIST 4-25]
> a = [42] 
[42]
> a.propertyIsEnumerable("0") 
true
> a.propertyIsEnumerable("length") 
false

==== 文字列に変換する

[LIST 4-26]
> ({a:1, b:2}).toString() 
"[object Object]"
> ({a:1, b:2}).toLocaleString() 
"[object Object]"

[LIST 4-27]
> date = new Date(Date.UTC(2019, 0)) 
Tue Jan 01 2019 09:00:00 GMT+0900 (日本標準時)
> date.toString() 
"Tue Jan 01 2019 09:00:00 GMT+0900 (日本標準時)"
> date.toLocaleString("ja-JP", { timeZone: "UTC" }) 
"2019/1/1 0:00:00"
> date.toLocaleString("en-US", { timeZone: "UTC" }) 
"1/1/2019, 12:00:00 AM"

=== Objectクラス経由で利用する機能

==== オブジェクトを生成する

[LIST 4-28]
> Object() 
{}
> new Object() 
{}

[LIST 4-29]
> Object.fromEntries([["x", 3], ["y", 4]]) 
{x: 3, y: 4}

[LIST 4-30]
> vec = Object.create(Object.prototype, { 
    x: { 
      value: 3, 
      writable: true, 
      enumerable: true, 
    }, 
    y: { 
      value: 4, 
      writable: true, 
      enumerable: true, 
    }, 
    length: { 
      enumerable: false, 
      get: function () { 
        return Math.sqrt(this.x * this.x + this.y * this.y) 
      }, 
      set: function (len) { 
        const current = this.length 
        this.x *= len / current 
        this.y *= len / current 
      } 
    } 
  }) 
{x: 3, y: 4}

[LIST 4-31]
> vec.length 
5
> vec.length = 50 
50
> vec 
{x: 30, y: 40}

==== オブジェクトの拡張性を管理する

[LIST 4-32]
> const checkStatus = (obj) => `拡張:${Object.isExtensible(obj)} 
  凍結:${Object.isFrozen(obj)} 
  封印:${Object.isSealed(obj)}` 
undefined
> checkStatus({answer:42}) 
"拡張:true
凍結:false
封印:false"
> checkStatus(Object.preventExtensions({answer:42})) 
"拡張:false
凍結:false
封印:false"
> checkStatus(Object.seal({answer:42})) 
"拡張:false
凍結:false
封印:true"
> checkStatus(Object.freeze({answer:42})) 
"拡張:false
凍結:true
封印:true"

==== プロパティを一覧する

[LIST 4-33]
> let obj = {bro1:"Mycroft", bro2:"Sherlock", [Symbol("sys")]:"Eurus"} 
undefined
> Object.getOwnPropertyNames(obj) 
(2) ["bro1", "bro2"]
> Object.getOwnPropertySymbols(obj) 
[Symbol(sys)]
> Object.keys(obj) 
(2) ["bro1", "bro2"]
> Object.values(obj) 
(2) ["Mycroft", "Sherlock"]
> Object.entries(obj) 
(2) [Array(2), Array(2)]
  0: (2) ["bro1", "Mycroft"]
  1: (2) ["bro2", "Sherlock"]
  length: 2
  __proto__: Array(0)

[LIST 4-34]
> clone = Object.fromEntries(Object.entries(obj)) 
{bro1: "Mycroft", bro2: "Sherlock"}

==== プロパティを管理する

[LIST 4-35]
> let vec = {} 
undefined
> Object.defineProperties(vec, { 
    x: {value: 3, writable: true, enumerable: true, configurable: true}, 
    y: {value: 4, writable: true, enumerable: true} 
  }) 
{x: 3, y: 4}
> Object.defineProperty(vec, "length", { 
    enumerable: false, 
    get: function () { 
      return Math.sqrt(this.x * this.x + this.y * this.y) 
    }, 
    set: function (len) { 
      const current = this.length 
      this.x *= len / current 
      this.y *= len / current 
    } 
  }) 
{x: 3, y: 4}
> Object.getOwnPropertyDescriptors(vec) 
{x: {…}, y: {…}, length: {…}}
> Object.getOwnPropertyDescriptor(vec, "length") 
{enumerable: false, configurable: false, get: ƒ, set: ƒ}

[LIST 4-36]
> Object.defineProperty( 
    vec, "x", {value: 5, writable: true, enumerable: false}) 
{y: 4, x: 5}

[LIST 4-37]
> Object.defineProperty( 
    vec, "y", {value: 5, writable: true, enumerable: false}) 
Uncaught TypeError: Cannot redefine property: y
    at Function.defineProperty (<anonymous>)
    at <anonymous>:1:8

[LIST 4-38]
> Object.defineProperty( 
    vec, "length", {value: 5, writable: true, enumerable: true}) 
Uncaught TypeError: Cannot redefine property: length
    at Function.defineProperty (<anonymous>)
    at <anonymous>:1:8

[LIST 4-39]
> vec.z = 1 
1
> Object.getOwnPropertyDescriptor(vec, "z") 
{value: 1, writable: true, enumerable: true, configurable: true}

==== プロパティをコピーする

[LIST 4-40]
> let parameters = {power: "B", speed: "C"}, 
      params1 = {range: "D"}, 
      params2 = {durability: "C"} 
undefined
> Object.assign(parameters, params1, params2) 
{power: "B", speed: "C", range: "D", durability: "C"}
> parameters 
{power: "B", speed: "C", range: "D", durability: "C"}

[LIST 4-41]
> clone = Object.assign({}, parameters) 
{power: "B", speed: "C", range: "D", durability: "C"}
> clone === parameters 
false

[LIST 4-42]
> let params3 = { 
    [Symbol("precision")]: "D", 
    get development() { return "C" } 
  } 
undefined
> Object.assign(parameters, params3) 
{power: "B", speed: "C", range: "D", durability: "C", development: …}
> parameters 
{power: "B", speed: "C", range: "D", durability: "C", development: …}
  development: "C"
  durability: "C"
  power: "B"
  range: "D"
  speed: "C"
  Symbol(precision): "D"
  __proto__: Object

==== オブジェクトの同一性を確認する

[LIST 4-43]
> Object.is(+0, -0) 
false
> +0 === -0 
true
> Object.is(NaN, NaN) 
true
> NaN === NaN 
false

==== オブジェクトのクラスを確認する

[LIST 4-44]
> class Vector2 {} 
undefined
> let vec = new Vector2() 
undefined
> typeof vec 
"object"

[LIST 4-45]
> vec instanceof Vector2 
true
> vec instanceof Object 
true
> vec instanceof Date 
false

[LIST 4-46]
> Object.getPrototypeOf(vec) 
{constructor: ƒ}
  constructor: class Vector2
  __proto__: Object

== まとめ

== 練習問題

= モジュールを学ぶ

== HTMLファイルでモジュールとしてJavaScriptファイルを読み込む

[LIST 5-1]
<!doctype html>
<html>
  <head>
    <script type="module" src="module.js"></script>
  </head>
</html>

[LIST 5-2]
<script type="module">
  import "./module.js"
</script>

== 他のモジュールで外部公開されたオブジェクトを使用する

[LIST 5-3]
import 〈インポート対象〉 from "〈モジュール名〉"

[LIST 5-4]
import "〈モジュール名〉"

[LIST 5-5]
console.log("モジュールの副作用")

[LIST 5-6]
<script type="module">
console.log("最初のインポート")
import "./sideeffect.js"
console.log("二度目のインポート")
import "./sideeffect.js"
console.log("終了")
</script>

[LIST 5-7]
sideeffect.js:1 モジュールの副作用
(index):6 最初のインポート
(index):8 二度目のインポート
(index):10 終了

=== オブジェクトを指定してインポートする

[LIST 5-8]
import { Klass, func } from "./module.js"

[LIST 5-9]
globalThis.Klass = Klass
window.func = func

==== 別名を付けてインポートする

[LIST 5-10]
import { Klass, func } from "./module.js"
import { Klass as Klass2, func as func2 } from "./module2.js"

==== モジュールオブジェクトのプロパティとしてインポートする

[LIST 5-11]
import * as Module from "./module.js"
console.log(Module.Klass, Module.func, Module.variable, Module.constant)

[LIST 5-12]
class Klass {} ƒ func() { return "module func" } "var" "constant"

=== デフォルトエクスポートをインポートする

[LIST 5-13]
import Module from "./module.js"
console.log(mod)

[LIST 5-14]
import Module, { Klass, func } from "./module.js"
console.log(Module, Klass, func)

[LIST 5-15]
class Klass {} ƒ func() { return "module func" } "var" "constant" 
class Klass {} ƒ func() { return "module func" }

== 動的にモジュールをインポートする

[LIST 5-16]
import("./module.js").then(Module => {
  console.log(Module)
})

[LIST 5-17]
Module {…}
  Klass: (...)
  constant: (...)
  default: (...)
  func: (...)
  variable: (...)
  Symbol(Symbol.toStringTag): "Module"
  ...

== モジュール内で定義されたオブジェクトをエクスポートする

=== 名前付きエクスポートする

[LIST 5-18]
export class Klass { }
export function func() { }
export let variable = "var"
export const constant = "constant"

[LIST 5-19]
class Klass {}
function func() { return "module func" }
let variable = "var"
const constant = "constant"

export { Klass, func, variable, constant }

[LIST 5-20]
export {
  Klass as K,
  func as f,
  variable as v,
  constant as c
}

=== デフォルトエクスポートする

[LIST 5-21]
export { Klass as default }

[LIST 5-22]
export { Klass as default, func, variable, constant }

[LIST 5-23]
export default class {}
export default function() {}
const constant = "constant"
export default constant

== インポートしたオブジェクトをエクスポートする

=== インポートした名前付きエクスポートをエクスポートする

[LIST 5-24]
export { Klass, func } from "./submodule.js"

[LIST 5-25]
export { Klass as K, func as f } from "./submodule.js"

[LIST 5-26]
export * from "./submodule.js"

=== インポートしたデフォルトエクスポートをエクスポートする

[LIST 5-27]
export { default } from "./submodule.js"

== まとめ

== 練習問題

[LIST 5-28]
class Klass {}
export { Klass as K }

= 基本的な標準オブジェクトを学ぶ

== プリミティブに対応するオブジェクト

[LIST 6-1]
> 42n.toString() 
"42"
> true.toString() 
"true"

=== オブジェクトとプリミティブを相互に変換する

[LIST 6-2]
> Object(true) 
Boolean {true}
> new Object(true) 
Boolean {true}
> Object(42) 
Number {42}
> new Object(42) 
Number {42}

[LIST 6-3]
> Object(true).valueOf() 
true
> Object(42).valueOf() 
42

[LIST 6-4]
> Boolean(1) 
true
> Boolean(0) 
false
> Boolean(undefined) 
false
> Boolean(null) 
false

[LIST 6-5]
> Number(Object(42)) 
42
> Number(true) 
1
> Number(undefined) 
NaN
> Number(null) 
0
> Number("42") 
42
> Number("4e2") 
400
> Number("42n") 
NaN

=== Booleanオブジェクト

[LIST 6-6]
> falseObject = new Boolean(false) 
Boolean {false}
> falseObject ? "true" : "false" 
"true"

=== Numberオブジェクト

[LIST 6-7]
> new Number(42) 
Number {42}
> +new Number(42) 
42
> new Number(6) * new Number(7) 
42

==== 数値の内部的な表現を理解する

==== さまざまな最大値と最小値

[LIST 6-8]
> Number.MAX_VALUE 
1.7976931348623157e+308
> Number.MAX_VALUE + 100 
1.7976931348623157e+308
> Number.MAX_VALUE + Number.MAX_VALUE 
Infinity

[LIST 6-9]
           0 11111111110 111...111
           - ----------- ---------
　　符号ビット 指数部　　　　仮数部　

[LIST 6-10]
> Number.MIN_VALUE 
5e-324
> Number.MIN_VALUE/1.9 
5e-324
> Number.MIN_VALUE/2 
0

[LIST 6-11]
           0 00000000000 000...001
           - ----------- ---------
　　符号ビット 指数部　　　　仮数部　

[LIST 6-12]
> Number.MAX_SAFE_INTEGER 
9007199254740991
> Number.MIN_SAFE_INTEGER 
-9007199254740991

[LIST 6-13]
> 2**53 - 1 
9007199254740991

[LIST 6-14]
> Number.MAX_SAFE_INTEGER + 1 
9007199254740992

[LIST 6-15]
> Number.MAX_SAFE_INTEGER + 2 
9007199254740992

[LIST 6-16]
> Number.MAX_SAFE_INTEGER + 3 
9007199254740994
> Number.MAX_SAFE_INTEGER + 4 
9007199254740996

[LIST 6-17]
> Number.isSafeInteger(42) 
true
> Number.isSafeInteger(3.14) 
false
> Number.isSafeInteger(Number.MAX_SAFE_INTEGER) 
true
> Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) 
false

[LIST 6-18]
> Number.isInteger(1) 
true
> Number.isInteger(0.1) 
false
> Number.isInteger(Number.MAX_SAFE_INTEGER) 
true
> Number.isInteger(Number.MAX_VALUE) 
true

==== 特殊な数を利用する

[LIST 6-19]
> Number.POSITIVE_INFINITY 
Infinity
> Number.NEGATIVE_INFINITY 
-Infinity

[LIST 6-20]
> 10**10**10**122 
Infinity
> 1 / 0 
Infinity

[LIST 6-21]
> Infinity + Number.MAX_VALUE 
Infinity
> Infinity - Number.MAX_VALUE 
Infinity
> Infinity * Number.MAX_VALUE 
Infinity
> Infinity / Number.MAX_VALUE 
Infinity

[LIST 6-22]
> Infinity === Infinity 
true
> Number.POSITIVE_INFINITY === Infinity 
true
> Number.isFinite(Infinity) 
false

[LIST 6-23]
> 0 / 0 
NaN

[LIST 6-24]
> Number.NaN 
NaN

[LIST 6-25]
> Infinity / Infinity 
NaN
> Infinity - Infinity 
NaN
> Infinity * 0 
NaN

[LIST 6-26]
> Number.isNaN(0/0) 
true

[LIST 6-27]
> NaN === NaN 
false
> NaN == NaN 
false
> NaN == 0 
false

[LIST 6-28]
 Infinity  0 11111111111 000...000
-Infinity  1 11111111111 000...000
 NaN       0 11111111111 000...001
 NaN       0 11111111111 000...010
           - ----------- ---------
　　符号ビット 指数部　　　　仮数部　

==== 文字列から数値に変換する

[LIST 6-29]
> Number.parseFloat("0.123") 
0.123
> Number.parseFloat("10e-4") 
0.001

[LIST 6-30]
> Number.parseFloat("   -1.2です") 
-1.2

[LIST 6-31]
> Number.parseFloat(true) 
NaN

[LIST 6-32]
> Number.parseInt("1") 
1
> Number.parseInt("1.23") 
1
> Number.parseInt("10e3") 
10

[LIST 6-33]
> Number.parseInt("11", 2) 
3
> Number.parseInt("hello", 36) 
29234652
> Number.parseInt("11", 100) 
NaN

[LIST 6-34]
> Number.parseInt("0b11") 
0
> Number.parseInt("011") 
11
> Number.parseInt("0xff") 
255

==== 数値から文字列に変換する

[LIST 6-35]
> (42).toString() 
"42"
> (42).toString(2) 
"101010"
> 9.80665.toString(16) 
"9.ce809d4951828"
> 9.80665.toString(25) 
"9.k43mga3mga2"

[LIST 6-36]
> 42.toString() 
Uncaught SyntaxError: Invalid or unexpected token

[LIST 6-37]
> 42..toString() 
"42"

[LIST 6-38]
> (101325).toLocaleString("en") 
"101,325"
> (101325).toLocaleString("de") 
"101.325"
> (101325).toLocaleString("ja-JP-u-nu-hanidec",  
    { style: "currency", currency: "JPY" }) 
"￥一〇一,三二五"

[LIST 6-39]
> (42).toFixed(3) 
"42.000"
> (42).toExponential(4) 
"4.2000e+1"
> (42).toPrecision(5) 
"42.000"
> (42).toPrecision(1) 
"4e+1"

==== 数学の関数を利用する

[LIST 6-40]
> Math.sin(30/180 * Math.PI) 
0.49999999999999994
> Math.acos(1) 
0
> Math.sqrt(1764) 
42
> Math.pow(10, 10) 
10000000000
> Math.round(9.80665) 
10
> Math.max(Math.PI, Math.E, 1) 
3.141592653589793

=== BigIntオブジェクト

[LIST 6-41]
> BigInt(6.02214179e23) 
602214178999999989284864n
> BigInt("0x7f8618974d08a8000000") 
602214178999999989284864n
> BigInt(true) 
1n
> new BigInt(42) 
Uncaught TypeError: BigInt is not a constructor
    at new BigInt (<anonymous>)
    at <anonymous>:1:1

[LIST 6-42]
> BigInt.asUintN(3, 7n) 
7n
> BigInt.asUintN(3, 8n) 
0n

[LIST 6-43]
> BigInt.asIntN(3, 2n) 
2n
> BigInt.asIntN(3, 3n) 
3n
> BigInt.asIntN(3, 4n) 
-4n
> BigInt.asIntN(3, 5n) 
-3n

=== Stringオブジェクト

==== 文字列の内部的な表現を理解する

[LIST 6-44]
[
  0xd869, 0xde02, // 𪘂（2A602）
  0x6b6f,         // 歯（6B6F）
  0x985e,         // 類（985E）
  0x304c,         // が（304C）
  0xd84f, 0xdd40, // 𣵀（23D40）
  0x69c3,         // 槃（69C3）
  0x3067,         // で（3067）
  0x5f85,         // 待（5F85）
  0x3064          // つ（3064）
]

==== 文字列の一部を取り出す

[LIST 6-45]
> const isbn = "9784873117706" 
undefined
> isbn.charAt(3) 
"4"
> isbn.charAt() 
"9"
> isbn.charAt(-1) 
""
> isbn.charAt(42) 
""

[LIST 6-46]
> const nirvana = "𪘂歯類が𣵀槃で待つ" 
undefined
> nirvana.charAt(0) 
"�"
> nirvana.charAt(1) 
"�"
> nirvana.charAt(2) 
"歯"
> nirvana.charAt(3) 
"類"

[LIST 6-47]
> isbn 
"9784873117706"
> isbn.slice(0, 3) 
"987"
> isbn.slice(5, 10) 
"73117"
> isbn.slice(10) 
"706"
> isbn.slice(10, 100) 
"706"

[LIST 6-48]
> isbn.slice(10, 5) 
""

[LIST 6-49]
> nirvana 
"𪘂歯類が𣵀槃で待つ"
> nirvana.slice(0, 4) 
"𪘂歯類"
> nirvana.slice(1, 4) 
"�歯類"
> nirvana.slice(1, 6) 
"�歯類が�"

[LIST 6-50]
> isbn 
"9784873117706"
> isbn.slice(-10, -8) 
"48"
> isbn.slice(13-10, 13-8) 
"48"
> isbn.slice(3, 5) 
"48"

==== 文字列を調べる

[LIST 6-51]
> isbn 
"9784873117706"
> isbn.length 
13

[LIST 6-52]
> nirvana 
"𪘂歯類が𣵀槃で待つ"
> nirvana.length 
11

[LIST 6-53]
> isbn 
"9784873117706"
> isbn.startsWith("978") 
true
> isbn.startsWith("979") 
false

[LIST 6-54]
> isbn 
"9784873117706"
> isbn.startsWith("48", 3) 
true

[LIST 6-55]
> isbn 
"9784873117706"
> isbn.endsWith("706") 
true
> isbn.endsWith("73117", 10) 
true

[LIST 6-56]
> isbn 
"9784873117706"
> isbn.includes("48") 
true
> isbn.includes("48", 5) 
false

[LIST 6-57]
> isbn 
"9784873117706"
> isbn.indexOf("48") 
3
> isbn.indexOf("42") 
-1

[LIST 6-58]
> isbn 
"9784873117706"
> isbn.indexOf("7") 
1
> isbn.indexOf("7", 1+1) 
5
> isbn.indexOf("7", 5+1) 
9
> isbn.indexOf("7", 9+1) 
10
> isbn.indexOf("7", 10+1) 
-1

[LIST 6-59]
> isbn 
"9784873117706"
> isbn.lastIndexOf("7") 
10

==== 文字列を変更する

[LIST 6-60]
> isbn 
"9784873117706"
> isbn.replace("7", "*") 
"9*84873117706"

[LIST 6-61]
> isbn 
"9784873117706"
> isbn.replace(/7/g, "*") 
"9*848*311**06"

[LIST 6-62]
> "   9784873117706\n".trim() 
"9784873117706"

[LIST 6-63]
> isbn 
"9784873117706"
> isbn.padStart(15) 
"  9784873117706"
> isbn.padEnd(15) 
"9784873117706  "

[LIST 6-64]
> isbn 
"9784873117706"
> isbn.padStart(10) 
"9784873117706"

[LIST 6-65]
> isbn 
"9784873117706"
> isbn.padStart(18, "#") 
"#####9784873117706"
> isbn.padEnd(18, ".oO") 
"9784873117706.oO.o"

[LIST 6-66]
> isbn 
"9784873117706"
> isbn.repeat(3) 
"978487311770697848731177069784873117706"

[LIST 6-67]
> "lisp".toUpperCase() 
"LISP"
> "PYTHON".toLowerCase() 
"python"
> "ぁぃぅぇぉ".toUpperCase() 
"ぁぃぅぇぉ"

==== 文字列を分割／結合する

[LIST 6-68]
> "012-3456-7890".split("-") 
(3) ["012", "3456", "7890"]

[LIST 6-69]
> "012-3456-7890".split("-", 2) 
(2) ["012", "3456"]

[LIST 6-70]
> "012".concat("-", "3456", "-", "7890") 
"012-3456-7890"

==== Unicodeを扱う

[LIST 6-71]
> "\u{2a602}\u{6b6f}\u{985e}" 
"𪘂歯類"

[LIST 6-72]
> "\ud869\ude02\u6b6f\u985e" 
"𪘂歯類"

[LIST 6-73]
> String.fromCodePoint(0x2a602, 0x6b6f, 0x985e) 
"𪘂歯類"
> String.fromCharCode(0xd869, 0xde02, 0x6b6f, 0x985e) 
"𪘂歯類"
> "\u{2a602}\u{6b6f}\u{985e}".codePointAt(0).toString(16) 
"2a602"
> "\ud869\ude02\u6b6f\u985e".codePointAt(0).toString(16) 
"2a602"
> "\u{2a602}\u{6b6f}\u{985e}".charCodeAt(0).toString(16) 
"d869"
> "\ud869\ude02\u6b6f\u985e".charCodeAt(0).toString(16) 
"d869"

=== Symbolオブジェクト

[LIST 6-74]
> const s1 = Symbol() 
undefined
> const s2 = Symbol() 
undefined
> s1 == s2 
false

[LIST 6-75]
> const s1 = Symbol("desc") 
undefined
> const s2 = Symbol("desc") 
undefined
> s1 == s2 
false

[LIST 6-76]
> new Symbol() 
Uncaught TypeError: Symbol is not a constructor
    at new Symbol (<anonymous>)
    at <anonymous>:1:1

==== シンボルをプロパティのキーとして使用する

[LIST 6-77]
> range = Symbol("range") 
Symbol(range)
> theFool = {} 
{}
> theFool[range] = "D" 
"D"
> theFool[range] 
"D"
> theFool[Symbol("range")] 
undefined

[LIST 6-78]
> power = Symbol("power") 
Symbol(power)
> theFool = {[power]: "B"} 
{Symbol(power): "B"}
> theFool[power] 
"B"

==== グローバルシンボルレジストリを利用する

[LIST 6-79]
> speed = Symbol.for("speed") 
Symbol(speed)
> speed === Symbol.for("speed") 
true
> speed === Symbol("speed") 
false

[LIST 6-80]
> Symbol.keyFor(speed) 
"speed"
> Symbol.keyFor(power) 
undefined

==== Well-Known Symbol

[LIST 6-81]
> Symbol.iterator 
Symbol(Symbol.iterator)
> Symbol.toStringTag 
Symbol(Symbol.toStringTag)

[LIST 6-82]
> let Suit = { 
    [Symbol.hasInstance]:  
      v => ["spade", "club", "heart", "diamond"].includes(v) 
  } 
undefined
> "spade" instanceof Suit 
true
> "kimono" instanceof Suit 
false

[LIST 6-83]
> let bat = { 
    [Symbol.toPrimitive]: 
      hint => ({default:0, number:42, string:"str"})[hint] 
  } 
undefined
> "" + bat 
"0"
> +bat 
42
> `${bat}` 
"str"

[LIST 6-84]
> ({}).toString() 
"[object Object]"
> new Map().toString() 
"[object Map]"

[LIST 6-85]
> emporio = { 
    [Symbol.toStringTag]: "I'm Emporio" 
  } 
I'm Emporio {Symbol(Symbol.toStringTag): "I'm Emporio"}
> emporio.toString() 
"[object I'm Emporio]"

== 直接生成できるオブジェクト

=== Functionオブジェクト

[LIST 6-86]
> function whatILikeDoingBest() {} 
undefined
> whatILikeDoingBest instanceof Function 
true
> (() => {}) instanceof Function 
true

[LIST 6-87]
> let getAverage = new Function("n1", "n2", "n3", "return (n1 + n2 + n3) / 3") 
undefined
> getAverage(3, 48, 75) 
42

[LIST 6-88]
> function add3(num1, num2) { return this + num1 + num2 } 
undefined
> add3.apply(1, [16, 25]) 
42
> add3.call(1, 16, 25) 
42

[LIST 6-89]
> add2 = add3.bind(1) 
ƒ add3(num1, num2) { return this + num1 + num2 }
> add2(16, 25) 
42
> add2.call(999, 16, 25) 
42
> add1 = add3.bind(1, 16) 
ƒ add3(num1, num2) { return this + num1 + num2 }
> add1(25) 
42
> add1.call(999, 25) 
42

=== RegExpオブジェクト

[LIST 6-90]
> shout = /URY+/ 
/URY+/

[LIST 6-91]
> shout 
/URY+/
> match = "URYYY".match(shout) 
["URYYY", index: 0, input: "URYYY", groups: undefined]
> match = "8 seconds! URYYY".match(shout) 
["URYYY", index: 11, input: "8 seconds! URYYY", groups: undefined]
> match = "WRYYY".match(shout) 
null

==== 繰り返しを指定する

[LIST 6-92]
> shout 
/URY+/
> match = "UR".match(shout) 
null
> match = "URY".match(shout) 
["URY", index: 0, input: "URY", groups: undefined]

[LIST 6-93]
> shout 
/URY+/
> "UR".match(/URY?/) 
["UR", index: 0, input: "UR", groups: undefined]
> "URY".match(/URY?/) 
["URY", index: 0, input: "URY", groups: undefined]
> "URYY".match(/URY?/) 
["URY", index: 0, input: "URYY", groups: undefined]
> "UR".match(/URY*/) 
["UR", index: 0, input: "UR", groups: undefined]
> "URY".match(/URY*/) 
["URY", index: 0, input: "URY", groups: undefined]
> "URYYYY".match(/URY*/) 
["URYYYY", index: 0, input: "URYYYY", groups: undefined]

==== パターンの分岐を指定する

[LIST 6-94]
> shout = /URY+|WRY+/ 
/URY+|WRY+/
> match = "URYYY".match(shout) 
["URYYY", index: 0, input: "URYYY", groups: undefined]
> match = "WRYYY".match(shout) 
["WRYYY", index: 0, input: "WRYYY", groups: undefined]

[LIST 6-95]
> shout = /URY+|UREY+|WRY+/ 
/URY+|UREY+|WRY+/
> match = "UREYYY".match(shout) 
["UREYYY", index: 0, input: "UREYYY", groups: undefined]

==== 正規表現の一部をグループ化する

[LIST 6-96]
> shout = /(U|W)RE?Y+/ 
/(U|W)RE?Y+/
> match = "URYYY".match(shout) 
(2) ["URYYY", "U", index: 0, input: "URYYY", groups: undefined]
> match = "WRYYY".match(shout) 
(2) ["WRYYY", "W", index: 0, input: "WRYYY", groups: undefined]
> match = "WREYYY".match(shout) 
(2) ["WREYYY", "W", index: 0, input: "WREYYY", groups: undefined]

==== 文字種を指定する

[LIST 6-97]
> "(U|W)RE?Y+".match(/(U|W)RE?Y+/) 
null

[LIST 6-98]
> "(U|W)RE?Y+".match(/\(U\|W\)RE\?Y\+/) 
["(U|W)RE?Y+", index: 0, input: "(U|W)RE?Y+", groups: undefined]

[LIST 6-99]
> "I'm done with mankind, JOJO!".match(/\s\w+[!?]/) 
[" JOJO!", index: 22, input: "I'm done with mankind, JOJO!", groups: undefined]

==== 位置を指定する

[LIST 6-100]
> "I'm done with mankind, JOJO!".match(/^\S+/) 
["I'm", index: 0, input: "I'm done with mankind, JOJO!", groups: undefined]
> "I'm done with mankind, JOJO!".match(/\S+$/) 
["JOJO!", index: 23, input: "I'm done with mankind, JOJO!", groups: undefined]

==== オプションフラグを指定する

[LIST 6-101]
> `Uryyyy 
  Wreyyy UREYYYY 
  WRYYYY`.match(/^(u|w)re?y+/gim) 
(3) ["Uryyyy", "Wreyyy", "WRYYYY"]

==== 文字列のメソッドで正規表現を利用する

[LIST 6-102]
> "URYYY".search(/(U|W)RE?Y+/) 
0
> "UR".search(/(U|W)RE?Y+/) 
-1

[LIST 6-103]
> `What did 
  you say 
  about my 
  hair?!`.split(/\s+/) 
(7) ["What", "did", "you", "say", "about", "my", "hair?!"]

[LIST 6-104]
> "I reject my humanity! JOJO!!".replace(/!+/g, "?") 
"I reject my humanity? JOJO?"

[LIST 6-105]
> const length = { 
    [Symbol.search]: s => s.length 
  } 
undefined
> "Wryyyyy".search(length) 
7

[LIST 6-106]
> shout 
/(U|W)RE?Y+/
> shout[Symbol.match] 
ƒ [Symbol.match]() { [native code] }
> shout[Symbol.match]("WRYYY") 
(2) ["WRYYY", "W", index: 0, input: "WRYYY", groups: undefined]

==== 正規表現オブジェクトを使用する

[LIST 6-107]
> new RegExp("(u|w)re?y+", "i") 
/(u|w)re?y+/i

[LIST 6-108]
> new RegExp("\\\d+") 
/\d+/
> new RegExp("\d+") 
/d+/

[LIST 6-109]
> re = new RegExp("\\\\\\\") 
/\\/
> "\\\".match(re) 
["\", index: 0, input: "\", groups: undefined]

[LIST 6-110]
> shout 
/(U|W)RE?Y+/
> shout.test("WREYYYY") 
true
> shout.exec("URYYYY") 
(2) ["URYYYY", "U", index: 0, input: "URYYYY", groups: undefined]

== globalThisオブジェクト

[LIST 6-111]
> globalThis.Number 
ƒ Number() { [native code] }
> globalThis.Number === Number 
true
> globalThis.Infinity 
Infinity
> globalThis.Infinity === Infinity 
true

[LIST 6-112]
> globalThis 
Window {parent: Window, opener: null, top: Window, length: 1, frames: …}

[LIST 6-113]
> globalThis === window 
true

=== 組み込み関数

== まとめ

== 練習問題

[LIST 6-114]
const re = 正規表現
const html = `
  <html lang="ja">
    <head><!-- 頭 --></head>
    <body class="dark">体</body>
  </html>
`;
[...html.matchAll(re)].map(ary => ary[1])

= コレクションを学ぶ

== Array

=== 配列を生成する

[LIST 7-1]
> days = Array.of(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> pourelle = Array.of("the next", 3, days) 
(3) ["the next", 3, Array(12)]

[LIST 7-2]
> days2 = Array.from(days) 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
> days == days2 
false
> Array.from(new Set(days)) 
(3) [31, 28, 30]

[LIST 7-3]
> Array.from(days, i => i * i) 
(12) [961, 784, 961, 900, 961, 900, 961, 961, 900, 961, 900, 961]

[LIST 7-4]
> Array.from(days, function(i) { return this + i }, "No.") 
(12) ["No.31", "No.28", "No.31", "No.30", "No.31", "No.30", "No.31", "No.31", "No.30", "No.31", "No.30", "No.31"]

[LIST 7-5]
> Array.from(days, i => this + i, "No.") 
(12) ["[object Window]31", "[object Window]28", "[object Window]31", "[object Window]30", "[object Window]31", "[object Window]30", "[object Window]31", "[object Window]31", "[object Window]30", "[object Window]31", "[object Window]30", "[object Window]31"]

[LIST 7-6]
> new Array(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31) 
(12) [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]

[LIST 7-7]
> new Array(31) 
(31) [empty × 31]

[LIST 7-8]
> Array.prototype.reverse.call(arrayLike) 
{0: 8, 1: 5, 2: 3, length: 3}

[LIST 7-9]
> arrayLike = { 
    length:3, 
    0: 3, 
    1: 5, 
    2: 8 
  } 
{0: 3, 1: 5, 2: 8, length: 3}
> Array.from(arrayLike) 
(3) [3, 5, 8]

=== 配列を調べる

[LIST 7-10]
> Array.isArray([]) 
true
> Array.isArray([1, 1, 2, 3, 5, 8]) 
true
> Array.isArray("array") 
false
> Array.isArray(new Set) 
false

[LIST 7-11]
> [].length 
0
> [1, 1, 2, 3, 5, 8].length 
6

[LIST 7-12]
> undefineds = [undefined, undefined, undefined] 
(3) [undefined, undefined, undefined]
> undefineds.length 
3
> undefineds[0] 
undefined
> undefineds[10] 
undefined

[LIST 7-13]
> fib = [1, 1, 2, 3, 5, 8] 
(6) [1, 1, 2, 3, 5, 8]
> fib.length = 3 
3
> fib 
(3) [1, 1, 2]
> fib.length = 0 
0
> fib 
[]
> fib.length = 3 
3
> fib 
(3) [empty × 3]

[LIST 7-14]
> fib = [1, 1, 2, 3, 5, 8] 
(6) [1, 1, 2, 3, 5, 8]
> fib.includes(3) 
true
> fib.includes(13) 
false
> fib.includes("3") 
false

[LIST 7-15]
> [NaN].includes(NaN) 
true
> [+0].includes(-0) 
true

[LIST 7-16]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.includes(3, 1) 
true
> fib.includes(3, 4) 
false
> fib.includes(3, -4) 
true

[LIST 7-17]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.some(n => 4 < n) 
true
> fib.some(n => 13 < n) 
false

[LIST 7-18]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.every(n => 0 < n) 
true
> fib.every(n => 2 < n) 
false

=== 配列を検索する

[LIST 7-19]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.indexOf(1) 
0
> fib.lastIndexOf(1) 
1
> fib.findIndex(n => 4 < n) 
4
> fib.find(n => 4 < n) 
5
> fib.filter(n => 4 < n) 
(2) [5, 8]
> fib.indexOf(13) 
-1
> fib.find(n => 13 < n) 
undefined
> fib.filter(n => 13 < n) 
[]

[LIST 7-20]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.find((n, i, ary) => n === ary[i]) 
1
> fib.filter((n, i, ary) => n === ary[i]) 
(6) [1, 1, 2, 3, 5, 8]

=== 配列を並べ替える

[LIST 7-21]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.reverse() 
(6) [8, 5, 3, 2, 1, 1]
> fib 
(6) [8, 5, 3, 2, 1, 1]
> fib.reverse() 
(6) [1, 1, 2, 3, 5, 8]
> fib 
(6) [1, 1, 2, 3, 5, 8]

[LIST 7-22]
> [34, 21, 13, 8, 5, 3, 2, 1, 1].sort() 
(9) [1, 1, 13, 2, 21, 3, 34, 5, 8]

[LIST 7-23]
> [34, 21, 13, 8, 5, 3, 2, 1, 1].sort((a, b) => { 
      if (a < b) return -1; 
      if (a > b) return 1; 
      return 0; 
  }) 
(9) [1, 1, 2, 3, 5, 8, 13, 21, 34]

[LIST 7-24]
> [34, 21, 13, 8, 5, 3, 2, 1, 1].sort((a, b) => a - b) 
(9) [1, 1, 2, 3, 5, 8, 13, 21, 34]

=== 配列の要素を順に処理する

[LIST 7-25]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.forEach(n => console.log(n)) 
1
1
2
3
5
8
undefined

[LIST 7-26]
> for (const [i, n] of fib.entries()) { 
    console.log(`index:${i} value:${n}`) 
  } 
index:0 value:1
index:1 value:1
index:2 value:2
index:3 value:3
index:4 value:5
index:5 value:8
undefined

[LIST 7-27]
> for (const i of fib.keys()) { 
    console.log(`index:${i}`) 
  } 
index:0
index:1
index:2
index:3
index:4
index:5
undefined

[LIST 7-28]
> for (const i in fib) { 
    console.log(`index:${i}`) 
  } 
index:0
index:1
index:2
index:3
index:4
index:5
undefined

=== 配列の要素をまとめて更新する

[LIST 7-29]
> [1, 1, 2, 3, 5, 8].fill(0) 
(6) [0, 0, 0, 0, 0, 0]
> [1, 1, 2, 3, 5, 8].fill(0, 2) 
(6) [1, 1, 0, 0, 0, 0]
> [1, 1, 2, 3, 5, 8].fill(0, 2, 5) 
(6) [1, 1, 0, 0, 0, 8]

[LIST 7-30]
> [1, 1, 2, 3, 5, 8].fill(0, -4) 
(6) [1, 1, 0, 0, 0, 0]
> [1, 1, 2, 3, 5, 8].fill(0, -4, -2) 
(6) [1, 1, 0, 0, 5, 8]

[LIST 7-31]
> new Array(5).fill("無駄") 
(5) ["無駄", "無駄", "無駄", "無駄", "無駄"]

[LIST 7-32]
> [1, 2, 3, 4, 5].copyWithin(2) 
(5) [1, 2, 1, 2, 3]
> [1, 2, 3, 4, 5].copyWithin(2, 1) 
(5) [1, 2, 2, 3, 4]
> [1, 2, 3, 4, 5].copyWithin(2, 1, 3) 
(5) [1, 2, 2, 3, 5]

[LIST 7-33]
[1, 2, 3, 4, 5].copyWithin(2)
      [1, 2, 3, 4, 5]  // コピー対象
[1, 2, 1, 2, 3]        // 結果

[1, 2, 3, 4, 5].copyWithin(2, 1)
   [_, 2, 3, 4, 5]     // コピー対象
[1, 2, 2, 3, 4]        // 結果

[1, 2, 3, 4, 5].copyWithin(2, 1, 3)
   [_, 2, 3, _, _]     // コピー対象
[1, 2, 2, 3, 5]        // 結果

[LIST 7-34]
> [1, 2, 3, 4, 5].copyWithin(2, -4) 
(5) [1, 2, 2, 3, 4]
> [1, 2, 3, 4, 5].copyWithin(2, -4, -2) 
(5) [1, 2, 2, 3, 5]

[LIST 7-35]
> ary = [1, 2, 3, 4, 5] 
(5) [1, 2, 3, 4, 5]
> ary.splice(1, 3) 
(3) [2, 3, 4]
> ary 
(2) [1, 5]
> ary.splice(1, 0, 2, 3, 4) 
[]
> ary 
(5) [1, 2, 3, 4, 5]
> ary.splice(1, 3, -1, -2, -3) 
(3) [2, 3, 4]
> ary 
(5) [1, -1, -2, -3, 5]

=== 配列から異なる配列を生成する

[LIST 7-36]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.map(n => n * n) 
(6) [1, 1, 4, 9, 25, 64]

[LIST 7-37]
> fib 
(6) [1, 1, 2, 3, 5, 8]
> fib.map((n, i, ary) => `${i}:${n * n}`) 
(6) ["0:1", "1:1", "2:4", "3:9", "4:25", "5:64"]
> fib 
(6) [1, 1, 2, 3, 5, 8]

[LIST 7-38]
> ary = [1, 2, 3, 4, 5] 
(5) [1, 2, 3, 4, 5]
> ary.slice(2, 4) 
(2) [3, 4]
> ary.slice(2) 
(3) [3, 4, 5]
> ary.slice(-3) 
(3) [3, 4, 5]

[LIST 7-39]
> let src = [1, 2, 3, [4, 5]] 
  let dst = src.slice() 
  dst[1] = -2 
  dst[3][0] = -4 
-4
> dst 
(4) [1, -2, 3, Array(2)]
  0: 1
  1: -2
  2: 3
  3: (2) [-4, 5]
  length: 4
  __proto__: Array(0)
> src 
(4) [1, 2, 3, Array(2)]
  0: 1
  1: 2
  2: 3
  3: (2) [-4, 5]
  length: 4
  __proto__: Array(0)

[LIST 7-40]
> [[1, 1], [2, [3, 5], 8]].flat() 
(5) [1, 1, 2, Array(2), 8]

[LIST 7-41]
> [[1, 1], [2, [3, 5], 8]].flat(2) 
(6) [1, 1, 2, 3, 5, 8]

[LIST 7-42]
> [[1, 1], [2, 3], [5, 8]].flatMap(([n1, n2]) => n1 + n2) 
(3) [2, 5, 13]

=== 配列の各要素を処理してひとつの値を返す

[LIST 7-43]
> [1, 2, 3, 4, 5].reduce((sum, n) => sum += n, 0) 
15

[LIST 7-44]
> [1, 2, 3, 4, 5].reduce((sum, n) => sum += n) 
15

[LIST 7-45]
> [1, 2, 3, 4, 5].reduceRight((sum, n) => sum += n, "") 
"54321"
> [1, 2, 3, 4, 5].reduce((sum, n) => sum += n, "") 
"12345"

=== 配列を結合する

[LIST 7-46]
> ary = [1, 2, 3] 
(3) [1, 2, 3]
> ary.concat(4, 5, 6) 
(6) [1, 2, 3, 4, 5, 6]
> ary 
(3) [1, 2, 3]

[LIST 7-47]
> ary.concat([4, 5, 6]) 
(6) [1, 2, 3, 4, 5, 6]

[LIST 7-48]
> ary.concat(4, [5, 6], 7) 
(7) [1, 2, 3, 4, 5, 6, 7]

[LIST 7-49]
> ary.concat([4, [5, 6]]) 
(5) [1, 2, 3, 4, Array(2)]
  0: 1
  1: 2
  2: 3
  3: 4
  4: (2) [5, 6]
  length: 5
  __proto__: Array(0)

[LIST 7-50]
> ary.join() 
"1,2,3"
> ary.join("-") 
"1-2-3"
> ary.join("") 
"123"

=== 配列をスタックやキューとして扱う

[LIST 7-51]
> stack = [1, 2, 3, 4, 5] 
(5) [1, 2, 3, 4, 5]
> item = stack.pop() 
5
> stack 
(4) [1, 2, 3, 4]
> stack.push(6) 
5
> stack 
(5) [1, 2, 3, 4, 6]

[LIST 7-52]
> stack.push(7, 8, 9) 
8
> stack 
(8) [1, 2, 3, 4, 6, 7, 8, 9]

[LIST 7-53]
> queue = [1, 2, 3, 4, 5] 
(5) [1, 2, 3, 4, 5]
> item = queue.shift() 
1
> queue 
(4) [2, 3, 4, 5]
> queue.push(6) 
5
> queue 
(5) [2, 3, 4, 5, 6]

== TypedArray

=== 型付き配列の種類

[LIST 7-54]
> new Uint8Array([-1, 256]) 
Uint8Array(2) [255, 0]
> new Uint8ClampedArray([-1, 256]) 
Uint8ClampedArray(2) [0, 255]

=== 配列と共通する機能

[LIST 7-55]
> i8 = Int8Array.from([1, 2, 3, 4]) 
Int8Array(4) [1, 2, 3, 4]
> i82 = i8.filter(i => i % 2 == 0) 
Int8Array(2) [2, 4]
> i82.every(i => i % 2 == 0) 
true
> f32 = Float32Array.of(1, 2, 3, 4) 
Float32Array(4) [1, 2, 3, 4]
> f32.map(f => f * f).reduce((s, f) => s + f) 
30

=== 配列にあり型付き配列にはない機能

=== 配列になく型付き配列にある機能

[LIST 7-56]
> i8 = Int8Array.of(0, 0, 0, 0, 0) 
Int8Array(5) [0, 0, 0, 0, 0]
> i8.set([1, 2]) 
undefined
> i8 
Int8Array(5) [1, 2, 0, 0, 0]
> i8.set([4, 5], 3) 
undefined
> i8 
Int8Array(5) [1, 2, 0, 4, 5]

[LIST 7-57]
> i8.set([3, 4, 5, 6], 2) 
Uncaught RangeError: offset is out of bounds
    at Int8Array.set (<anonymous>)
    at <anonymous>:1:4

[LIST 7-58]
> i8.subarray(2) 
Int8Array(3) [0, 4, 5]
> i8.subarray(1, 4) 
Int8Array(3) [2, 0, 4]
> i8.subarray(1, -1) 
Int8Array(3) [2, 0, 4]

== Map

[LIST 7-59]
> map = new Map() 
Map(0) {}
> map.set(1, "number") 
Map(1) {1 => "number"}
> map.set("1", "string") 
Map(2) {1 => "number", "1" => "string"}
> map.get(1) 
"number"
> map.get("1") 
"string"

[LIST 7-60]
> obj = {} 
{}
> obj[1] = "number" 
"number"
> obj["1"] = "string" 
"string"
> obj[1] 
"string"
> obj["1"] 
"string"

=== Mapを生成する

[LIST 7-61]
> map = new Map([[1, "number"], ["1", "string"]]) 
Map(2) {1 => "number", "1" => "string"}

[LIST 7-62]
> new Map([[1, "number"], [1, "string"]]) 
Map(1) {1 => "string"}
> new Map([[1, 2, 3]]) 
Map(1) {1 => 2}
> new Map([[1]]) 
Map(1) {1 => undefined}
> new Map([[]]) 
Map(1) {undefined => undefined}
> new Map([]) 
Map(0) {}

[LIST 7-63]
> new Map(map) 
Map(2) {1 => "number", "1" => "string"}

[LIST 7-64]
> new Map(1) 
Uncaught TypeError: number 1 is not iterable (cannot read property
Symbol(Symbol.iterator))
    at new Map (<anonymous>)
    at <anonymous>:1:1
> new Map([1]) 
Uncaught TypeError: Iterator value 1 is not an entry object
    at new Map (<anonymous>)
    at <anonymous>:1:1
(anonymous) @ VM23046:1

=== Mapのエントリ数を取得する

[LIST 7-65]
> new Map().size 
0
> new Map([[1, 1], [2, 4], [3, 9]]).size 
3

=== Mapの値にアクセスする

[LIST 7-66]
> map = new Map() 
Map(0) {}
> map.set(true, "真偽値") 
Map(1) {true => "真偽値"}
> map.set(null, "Null値").set(undefined, "未定義値") 
Map(3) {true => "真偽値", null => "Null値", undefined => "未定義値"}
> obj = {} 
{}
> map.set(obj, "オブジェクト") 
Map(4) {true => "真偽値", null => "Null値", ..., {…} => "オブジェクト"}
> f = () => {} 
() => {}
> map.set(f, "関数") 
Map(5) {true => "真偽値", null => "Null値", ..., ƒ => "関数"}

[LIST 7-67]
> map.get(true) 
"真偽値"
> map.get(null) 
"Null値"
> map.get(undefined) 
"未定義値"

[LIST 7-68]
> map.get(obj) 
"オブジェクト"
> map.get(f) 
"関数"
> map.get({}) 
undefined
> map.get(() => {}) 
undefined

[LIST 7-69]
> map = new Map() 
Map(0) {}
> map.set("key", "Mapの値") 
Map(1) {"key" => "Mapの値"}
> map.key = "オブジェクトのプロパティ" 
"オブジェクトのプロパティ"
> map.get("key") 
"Mapの値"
> map.key 
"オブジェクトのプロパティ"

[LIST 7-70]
> map.has(true) 
true
> map.has("true") 
false

[LIST 7-71]
> map = new Map([["未定義", undefined]]) 
Map(1) {"未定義" => undefined}
> map.get("未定義") !== undefined 
false
> map.has("未定義") 
true

=== Mapの要素を削除する

[LIST 7-72]
> map.delete("未定義") 
true
> map.has("未定義") 
false
> map.delete("未定義") 
false

[LIST 7-73]
> map = new Map([["key1", 1], ["key2", 2], ["key3", 3]]) 
Map(3) {"key1" => 1, "key2" => 2, "key3" => 3}
> map.size 
3
> map.clear() 
undefined
> map.size 
0
> map 
Map(0) {}

=== Mapの要素を順に処理する

[LIST 7-74]
> map = new Map([["key1", 1], ["key2", 2]]) 
Map(2) {"key1" => 1, "key2" => 2}
> map.set("key3", 3) 
Map(3) {"key1" => 1, "key2" => 2, "key3" => 3}
> map.set("key4", 4) 
Map(4) {"key1" => 1, "key2" => 2, "key3" => 3, "key4" => 4}
> for (let [k, v] of map) { console.log(`キー:${k} 値:${v}`) } 
キー:key1 値:1
キー:key2 値:2
キー:key3 値:3
キー:key4 値:4
undefined
> map.forEach((v, k) => console.log(`キー:${k} 値:${v}`)) 
キー:key1 値:1
キー:key2 値:2
キー:key3 値:3
キー:key4 値:4
undefined

[LIST 7-75]
> for (e of map.entries()) { console.log(e) } 
(2) ["key1", 1]
(2) ["key2", 2]
(2) ["key3", 3]
(2) ["key4", 4]
undefined
> for (e of map.keys()) { console.log(e) } 
key1
key2
key3
key4
undefined
> for (e of map.values()) { console.log(e) } 
1
2
3
4
undefined

== Set

=== Setを生成する

[LIST 7-76]
> new Set() 
Set(0) {}
> new Set([1, "a", true]) 
Set(3) {1, "a", true}
> new Set([1, 2, 1, 2, 1, 2]) 
Set(2) {1, 2}

=== Setのエントリ数を取得する

[LIST 7-77]
> new Set([1, "a", true]).size 
3
> new Set([1, 2, 1, 2, 1, 2]).size 
2

=== Setのエントリにアクセスする

[LIST 7-78]
> set = new Set() 
Set(0) {}
> set.add(0) 
Set(1) {0}
> set.add("1").add(true) 
Set(3) {0, "1", true}

[LIST 7-79]
> set.add("1") 
Set(3) {0, "1", true}

[LIST 7-80]
> obj = {} 
{}
> set = new Set([obj]) 
Set(1) {{…}}
> set.add(obj) 
Set(1) {{…}}
> set.add({}) 
Set(2) {{…}, {…}}

[LIST 7-81]
> set.add(1) 
Set(3) {{…}, {…}, 1}
> set.has(1) 
true
> set.has(obj) 
true
> set.has({}) 
false

=== Setのエントリを削除する

[LIST 7-82]
> set 
Set(3) {{…}, {…}, 1}
> set.delete(1) 
true
> set 
Set(2) {{…}, {…}}
> set.delete(1) 
false

[LIST 7-83]
> set.clear() 
undefined
> set 
Set(0) {}

=== Setの要素を順に処理する

[LIST 7-84]
> set = new Set(["a", "b"]) 
Set(2) {"a", "b"}
> set.add("c") 
Set(3) {"a", "b", "c"}
> for (let c of set) { console.log(c) } 
a
b
c
undefined
> set.forEach(c => console.log(c)) 
a
b
c
undefined

[LIST 7-85]
> for (let c of set.values()) { console.log(c) } 
a
b
c
undefined
> for (let c of set.keys()) { console.log(c) } 
a
b
c
undefined
> for (let cs of set.entries()) { console.log(cs) } 
(2) ["a", "a"]
(2) ["b", "b"]
(2) ["c", "c"]
undefined

== WeakMap

=== メモリ管理と弱参照

=== WeakMapの特徴

=== WeakMapのメソッド

[LIST 7-86]
> obj1 = {}, obj2 = {}, obj3 = {} 
{}
> wm = new WeakMap([[obj1, "obj1"], [obj2, "obj2"]]) 
WeakMap {{…} => "obj2", {…} => "obj1"}
> wm.set(obj3, "obj3") 
WeakMap {{…} => "obj2", {…} => "obj3", {…} => "obj1"}
> wm.get(obj2) 
"obj2"
> wm.has(obj1) 
true
> wm.delete(obj1) 
true
> wm.has(obj1) 
false
> wm.set(1, "not reference") 
Uncaught TypeError: Invalid value used as weak map key
    at WeakMap.set (<anonymous>)
    at <anonymous>:1:4

== WeakSet

=== WeakSetのメソッド

[LIST 7-87]
> obj1 = {}, obj2 = {}, obj3 = {} 
{}
> ws = new WeakSet([obj1, obj2]) 
WeakSet {{…}, {…}}
> ws.add(obj3) 
WeakSet {{…}, {…}, {…}}
> ws.has(obj1) 
true
> ws.delete(obj1) 
true
> ws.has(obj1) 
false
> ws.add(1) 
Uncaught TypeError: Invalid value used in weak set
    at WeakSet.add (<anonymous>)
    at <anonymous>:1:4

== イテレータ

[LIST 7-88]
> [].entries() 
Array Iterator {}
> new Map().keys() 
MapIterator {}
> new Set().values() 
SetIterator {}

[LIST 7-89]
> iter = ["a", "b", "c"].values() 
Array Iterator {}
> iter.next() 
{value: "a", done: false}
> iter.next() 
{value: "b", done: false}
> iter.next() 
{value: "c", done: false}
> iter.next() 
{value: undefined, done: true}
> iter.next() 
{value: undefined, done: true}

[LIST 7-90]
function makeFizzBuzzIterator(max) {
  let count = 0
  return {
    next() {
      count++
      const done = max <= count
      if (count % 6 === 0) {
        return {value:"FizzBuzz", done}
      } else if (count % 2 === 0) {
        return {value:"Fizz", done}
      } else if (count % 3 === 0) {
        return {value:"Buzz", done}
      } else {
        return {value:count, done}
      }
    }
  }
}

[LIST 7-91]
> iter = makeFizzBuzzIterator(7) 
{next: ƒ}
> iter.next() 
{value: 1, done: false}
> iter.next() 
{value: "Fizz", done: false}
> iter.next() 
{value: "Buzz", done: false}
> iter.next() 
{value: "Fizz", done: false}
> iter.next() 
{value: 5, done: false}
> iter.next() 
{value: "FizzBuzz", done: false}
> iter.next() 
{value: 7, done: true}

[LIST 7-92]
> for (let v of iter) { console.log(v) } 
Uncaught TypeError: iter is not iterable
    at <anonymous>:1:11

=== イテラブル

[LIST 7-93]
> obj = [..."abc"] 
(3) ["a", "b", "c"]
> for (let item of obj) { 
    console.log(item) 
  } 
a
b
c
undefined

[LIST 7-94]
> for ( 
    let iter = obj[Symbol.iterator](), rslt = iter.next(), item = rslt.value; 
    !rslt.done; 
    rslt = iter.next(), item = rslt.value 
  ) { 
    console.log(item) 
  } 
a
b
c
undefined

[LIST 7-95]
> [][Symbol.iterator]() 
Array Iterator {}
> new Map()[Symbol.iterator]() 
MapIterator {}
> new Set()[Symbol.iterator]() 
SetIterator {}
> ""[Symbol.iterator]() 
StringIterator {}

[LIST 7-96]
> entriesIter = [].entries() 
Array Iterator {}
> entriesIter[Symbol.iterator]() === entriesIter 
true

[LIST 7-97]
> function makeFizzBuzzIterable(max) { 
    return { 
      [Symbol.iterator]() { 
        return makeFizzBuzzIterator(max) 
      } 
    } 
  } 
undefined
> for (item of makeFizzBuzzIterable(7)) { console.log(item) } 
1
Fizz
Buzz
Fizz
5
FizzBuzz
undefined

== ジェネレータ関数

=== ジェネレータ関数宣言

[LIST 7-98]
> function* generatorFunc() { 
    return "1200kVA" 
  } 

[LIST 7-99]
> generator = generatorFunc() 
generatorFunc {<suspended>}
> generator.next() 
{value: "1200kVA", done: true}
> generator[Symbol.iterator]() 
generatorFunc {<closed>}

[LIST 7-100]
> function* generatorFunc() { 
    console.log("処理1") 
    yield 1 
    console.log("処理2") 
    yield 2 
    console.log("処理3") 
    yield 3 
    console.log("処理4") 
    return 
  } 

[LIST 7-101]
> generator = generatorFunc() 
generatorFunc {<suspended>}
> generator.next() 
処理1
{value: 1, done: false}
> generator.next() 
処理2
{value: 2, done: false}
> generator.next() 
処理3
{value: 3, done: false}
> generator.next() 
処理4
{value: undefined, done: true}

[LIST 7-102]
> generator = generatorFunc() 
generatorFunc {<suspended>}
> for (let item of generator) { 
    console.log(item) 
  } 
処理1
1
処理2
2
処理3
3
処理4

[LIST 7-103]
> function* makeFizzBuzzGenerator(max) { 
    for (let count = 1; count <= max; count++) { 
      if (count % 6 === 0) { 
        yield "FizzBuzz" 
      } else if (count % 2 === 0) { 
        yield "Fizz" 
      } else if (count % 3 === 0) { 
        yield "Buzz" 
      } else { 
        yield count 
      } 
    } 
  } 

[LIST 7-104]
> fizzBuzzGenerator = makeFizzBuzzGenerator(7) 
makeFizzBuzzGenerator {<suspended>}
> for (let item of fizzBuzzGenerator) { 
    console.log(item) 
  } 
1
Fizz
Buzz
Fizz
5
FizzBuzz
7

=== ジェネレータ式

[LIST 7-105]
> let generatorExp = function*() { 
    yield 1 
    yield 2 
  } 

[LIST 7-106]
> for (let item of generatorExp()) { 
    console.log(item) 
  } 
1
2

=== ジェネレータメソッド

[LIST 7-107]
> obj = { 
    *generatorMethod() { 
      yield 1 
      yield 2 
    } 
  } 

[LIST 7-108]
> for (item of obj.generatorMethod()) { 
    console.log(item) 
  } 
1
2

=== ジェネレータオブジェクトのメソッド

[LIST 7-109]
> function* generatorFunc() { 
    console.log(yield 1) 
  } 
undefined
> generator = generatorFunc() 
generatorFunc {<suspended>}
> generator.next(100) 
{value: 1, done: false}
> generator.next(200) 
200
{value: undefined, done: true}

[LIST 7-110]
> function* generatorFunc() { 
    yield 1 
    yield 2 
    yield 3 
  } 
undefined
> generator = generatorFunc() 
generatorFunc {<suspended>}
> generator.next() 
{value: 1, done: false}
> generator.return(100) 
{value: 100, done: true}
> generator.next() 
{value: undefined, done: true}

[LIST 7-111]
> function* generatorFunc() { 
    try { 
      yield 1 
      yield 2 
      yield 3 
    } catch(e) { 
      console.log(e) 
      yield 4 
    } 
  } 
undefined
> generator = generatorFunc() 
generatorFunc {<suspended>}
> generator.next() 
{value: 1, done: false}
> generator.throw("エラー") 
エラー
{value: 4, done: false}

[LIST 7-112]
> generator.throw("エラー") 
Uncaught エラー
  generatorFunc @ VM6960:8
  (anonymous)   @ VM6973:1

== まとめ

== 練習問題

[LIST 7-113]
let map = new Map([["k1", "v1"]])
map.k1 = "v2"
console.log(map["k1"])

= 複雑なデータの扱いを学ぶ

== バイナリデータ

=== バイナリデータとテキストデータ

=== バイナリデータをそのまま保持する

[LIST 8-1]
> new ArrayBuffer(8) 
ArrayBuffer(8) {}

[LIST 8-2]
> new ArrayBuffer() 
ArrayBuffer(0) {}
> new ArrayBuffer(8.9) 
ArrayBuffer(8) {}
> new ArrayBuffer(-1) 
Uncaught RangeError: Invalid array buffer length
    at new ArrayBuffer (<anonymous>)
    at <anonymous>:1:1

[LIST 8-3]
> ab = new ArrayBuffer(8) 
ArrayBuffer(8) {}
> ab.byteLength 
8

[LIST 8-4]
> ab = new Int8Array([0, 1, 2, 3, 4]).buffer 
ArrayBuffer(5) {}
  [[Int8Array]]: Int8Array(5) [0, 1, 2, 3, 4]
  [[Uint8Array]]: Uint8Array(5) [0, 1, 2, 3, 4]
  byteLength: (...)
  __proto__: ArrayBuffer
> ab.slice(1, 4) 
ArrayBuffer(3) {}
  [[Int8Array]]: Int8Array(3) [1, 2, 3]
  [[Uint8Array]]: Uint8Array(3) [1, 2, 3]
  byteLength: (...)
  __proto__: ArrayBuffer

=== バイナリデータを読み書きする

==== ひとつの型からなるバイナリデータを扱う

[LIST 8-5]
> ab = new ArrayBuffer(4) 
ArrayBuffer(4) {}
> i8 = new Int8Array(ab) 
Int8Array(4) [0, 0, 0, 0]
> i8[0] = 1 
1
> i8[1] = 3 
3
> i8[2] = 7 
7
> i8[3] = 15 
15
> i8 
Int8Array(4) [1, 3, 7, 15]

[LIST 8-6]
> i16 = new Int16Array(ab) 
Int16Array(2) [769, 3847]
> i16[0] 
769
> i16[1] 
3847

[LIST 8-7]
> 0b00000001_00000011 
259
> 0b00000111_00001111 
1807

[LIST 8-8]
> 0b00000011_00000001 
769
> 0b00001111_00000111 
3847

[LIST 8-9]
> i32 = new Int32Array(ab) 
Int32Array [252117761]
> i32[0] 
252117761
> 0b00001111_00000111_00000011_00000001 
252117761

[LIST 8-10]
> i8 
Int8Array(4) [1, 3, 7, 15]
> new Int8Array(ab, 1, 2) 
Int8Array(2) [3, 7]
> new Int8Array(ab, 1) 
Int8Array(3) [3, 7, 15]

[LIST 8-11]
> new Int16Array(ab, 1) 
Uncaught RangeError: start offset of Int16Array should be a multiple of 2
    at new Int16Array (<anonymous>)
    at <anonymous>:1:1
> new Int16Array(ab, 2, 1) 
Int16Array [3847]

[LIST 8-12]
> Int16Array.BYTES_PER_ELEMENT 
2
> Int32Array.BYTES_PER_ELEMENT 
4
> new Int16Array(ab, 1 * Int16Array.BYTES_PER_ELEMENT, 1) 
Int16Array [3847]

[LIST 8-13]
> new Int32Array(new ArrayBuffer(7)) 
Uncaught RangeError: byte length of Int32Array should be a multiple of 4
    at new Int32Array (<anonymous>)
    at <anonymous>:1:1
(anonymous) @ VM2650:1
> new Int32Array(new ArrayBuffer(8)) 
Int32Array(2) [0, 0]

[LIST 8-14]
> f64 = new Float64Array(3) 
Float64Array(3) [0, 0, 0]
> i32 = new Int32Array([1, 1, 2, 3, 5]) 
Int32Array(5) [1, 1, 2, 3, 5]

[LIST 8-15]
> f64.buffer 
ArrayBuffer(24) {}
> i32.buffer 
ArrayBuffer(20) {}

[LIST 8-16]
> i32.buffer = new ArrayBuffer() 
ArrayBuffer(0) {}
> i32.buffer 
ArrayBuffer(20) {}

==== さまざまな型のバイナリデータを統一的に扱う

[LIST 8-17]
> ab = new Int8Array([1, 3, 7, 15, 31]).buffer 
ArrayBuffer(5) {}
> new DataView(ab) 
DataView(5) {}
> new DataView(ab, 1) 
DataView(4) {}
> new DataView(ab, 1, 3) 
DataView(3) {}

[LIST 8-18]
> ab = new ArrayBuffer(4) 
ArrayBuffer(4) {}
> dv = new DataView(ab) 
DataView(4) {}
> dv.setInt8(0, 1) 
undefined
> dv.setInt8(1, 3) 
undefined
> dv.setInt8(2, 7) 
undefined
> dv.setInt8(3, 15) 
undefined

[LIST 8-19]
00000001 00000011 00000111 00001111

[LIST 8-20]
> dv.getInt8(0).toString(2).padStart(8, "0") 
"00000001"
> dv.getInt8(1).toString(2).padStart(8, "0") 
"00000011"

[LIST 8-21]
> dv.getInt16(0).toString(2).padStart(16, "0") 
"0000000100000011"
> dv.getInt16(0, true).toString(2).padStart(16, "0") 
"0000001100000001"

[LIST 8-22]
> dv.getInt16(1).toString(2).padStart(16, "0") 
"0000001100000111"
> dv.getInt16(2).toString(2).padStart(16, "0") 
"0000011100001111"

[LIST 8-23]
> dv.getInt32(0).toString(2).padStart(32, "0") 
"00000001000000110000011100001111"
> dv.getInt32(0, true).toString(2).padStart(32, "0") 
"00001111000001110000001100000001"

[LIST 8-24]
> dv.getInt32(1) 
Uncaught RangeError: Offset is outside the bounds of the DataView
    at DataView.getInt32 (<anonymous>)
    at <anonymous>:1:4

== JavaScript Object Notation（JSON）

[LIST 8-25]
{
  "always_use_https": true,
  "discoverable_by_email": true,
  "geo_enabled": true,
  "language": "en",
  "protected": false,
  "screen_name": "theSeanCook",
  "show_all_inline_media": false,
  "sleep_time": {
    "enabled": false,
    "end_time": null,
    "start_time": null
  },
  "time_zone": {
    "name": "Pacific Time (US & Canada)",
    "tzinfo_name": "America/Los_Angeles",
    "utc_offset": -28800
  },
  "trend_location": [
    {
      "country": "United States",
      "countryCode": "US",
      "name": "Atlanta",
      "parentid": 23424977,
      "placeType": {
        "code": 7,
        "name": "Town"
      },
      "url": "http://where.yahooapis.com/v1/place/2357024",
      "woeid": 2357024
    }
  ],
  "use_cookie_personalization": true,
  "allow_contributor_request": "all"
}

=== JSONとオブジェクトリテラルの違い

=== JSON形式の文字列をオブジェクトに変換する

[LIST 8-26]
> JSON.parse("true") 
true
> ary = JSON.parse("[1, 1, [2, 3], 5]") 
(4) [1, 1, Array(2), 5]
> ary[2][1] 
3
> obj = JSON.parse('{"id":1, "name":"Echoes", "power":["E", "C", "B"]}') 
{id: 1, name: "Echoes", power: Array(3)}
> obj.power[1] 
"C"
> JSON.parse("40") + JSON.parse("2") 
42

[LIST 8-27]
> JSON.parse(`{"k":'v'}`) 
Uncaught SyntaxError: Unexpected token ' in JSON at position 5
    at JSON.parse (<anonymous>)
    at <anonymous>:1:6

[LIST 8-28]
> let reviver = (k, v) => { 
    console.log(`キー:${k} 値:${v}`) 
    return v instanceof Object ? v : `updated:${v}` 
  } 

[LIST 8-29]
> JSON.parse('{"id":1, "name":"Echoes", "power":["E", "C", "B"]}', reviver) 
キー:id 値:1
キー:name 値:Echoes
キー:0 値:E
キー:1 値:C
キー:2 値:B
キー:power 値:updated:E,updated:C,updated:B
キー: 値:[object Object]
  {id: "updated:1", name: "updated:Echoes", power: Array(3)}
    id: "updated:1"
    name: "updated:Echoes"
    power: (3) ["updated:E", "updated:C", "updated:B"]
    __proto__: Object

[LIST 8-30]
> JSON.parse(42, reviver) 
キー: 値:42
"updated:42"

[LIST 8-31]
> let reviver = (k, v) => Array.isArray(v) ? undefined : v 
undefined
> JSON.parse('{"id":1, "name":"Echoes", "power": ["E", "C", "B"]}', reviver) 
{id: 1, name: "Echoes"}

=== オブジェクトをJSON形式の文字列に変換する

[LIST 8-32]
> obj = {id: 1, name: "Echoes", power: ["E", "C", "B"]} 
{id: 1, name: "Echoes", power: Array(3)}
> JSON.stringify(obj) 
"{"id":1,"name":"Echoes","power":["E","C","B"]}"

[LIST 8-33]
> JSON.stringify(true) 
"true"
> JSON.stringify(42.0) 
"42"
> JSON.stringify('WRYYY') 
""WRYYY""

[LIST 8-34]
> JSON.stringify(new Boolean(true)) 
"true"
> JSON.stringify(new Number(42)) 
"42"
> JSON.stringify(new String("WRYYY")) 
""WRYYY""

[LIST 8-35]
> JSON.stringify(Symbol.iterator) 
undefined
> JSON.stringify(undefined) 
undefined

[LIST 8-36]
> params = Object.create(null, { 
    power: {value:"B", enumerable:true}, 
    speed: {value:"C", enumerable:false}, 
    [Symbol("range")]: {value:"D", enumerable:true} 
  }) 
{power: "B", speed: "C", Symbol(range): "D"}
> JSON.stringify(params) 
"{"power":"B"}"

[LIST 8-37]
> params = {power:"B", speed:"C", range:"D", toJSON() { return "secret"}} 
{power: "B", speed: "C", range: "D", toJSON: ƒ}
> JSON.stringify(params) 
""secret""

[LIST 8-38]
> let replacer = (k, v) => Array.isArray(v) ? v[0] : v 
undefined
> JSON.stringify({id:1, name:"Echoes", power:["E", "C", "B"]}, replacer) 
"{"id":1,"name":"Echoes","power":"E"}"

[LIST 8-39]
> range = Symbol("range") 
Symbol(range)
> params = Object.create(null, { 
    power: {value:"B", enumerable:true}, 
    speed: {value:"C", enumerable:false}, 
    [range]: {value:"D", enumerable:true} 
  }) 
{power: "B", speed: "C", Symbol(range): "D"}
> JSON.stringify(params, ["speed", range]) 
"{"speed":"C"}"

[LIST 8-40]
> JSON.stringify( 
    {id:1, name:"Echoes", power:["E", "C", "B"]}, undefined, 3) 
"{
   "id": 1,
   "name": "Echoes",
   "power": [
      "E",
      "C",
      "B"
   ]
}"

[LIST 8-41]
> JSON.stringify( 
    {id:1, name:"Echoes", power:["E", "C", "B"]}, undefined, "  ") 
"{
  "id": 1,
  "name": "Echoes",
  "power": [
    "E",
    "C",
    "B"
  ]
}"

[LIST 8-42]
> JSON.stringify( 
    {id:1, name:"Echoes", power:["E", "C", "B"]}, undefined, "[indent]") 
"{
[indent]"id": 1,
[indent]"name": "Echoes",
[indent]"power": [
[indent][indent]"E",
[indent][indent]"C",
[indent][indent]"B"
[indent]]
}"

=== オブジェクトをディープコピーする

[LIST 8-43]
> let ko1 = {id:1, name:"Echoes", parameters:[ 
    {power:"E", speed:"E", range:"B"}, 
    {power:"C", speed:"D", range:"B"}, 
    {power:"B", speed:"B", range:"C"}, 
  ]} 

[LIST 8-44]
> let ko2 = JSON.parse(JSON.stringify(ko1)) 
undefined
> ko2 
{id: 1, name: "Echoes", parameters: Array(3)}
> ko2.parameters[0].power = "A" 
"A"
> ko1.parameters[0].power 
"E"

== まとめ

== 練習問題

[LIST 8-45]
let binary = new Int32Array([-570238871, -1738642577]).buffer

[LIST 8-46]
let ko1 = {id: 1, name: "Echoes", parameters: [
  {power: "E", speed: "E", range: "B"},
  {power: "C", speed: "D", range: "B"},
  {power: "B", speed: "B", range: "C"},
]}

= 国際化を学ぶ

== 日時を扱う

=== 日付を作成する

[LIST 9-1]
> new Date() 
Wed Apr 01 2020 00:00:00 GMT+0900 (日本標準時)

[LIST 9-2]
> new Date(1868, 3, 4) 
Sat Apr 04 1868 00:00:00 GMT+0918 (日本標準時)

[LIST 9-3]
> new Date(20, 8, 27) 
Mon Sep 27 1920 00:00:00 GMT+0900 (日本標準時)

[LIST 9-4]
> new Date(0) 
Thu Jan 01 1970 09:00:00 GMT+0900 (日本標準時)

[LIST 9-5]
> new Date("1985-04-16T00:00:00+02:00") 
Tue Apr 16 1985 07:00:00 GMT+0900 (日本標準時)

[LIST 9-6]
> Date.now() 
1585666800000

[LIST 9-7]
> new Date(Date.UTC(1920, 8, 27)) 
Mon Sep 27 1920 09:00:00 GMT+0900 (日本標準時)

=== Dateオブジェクトのプロパティにアクセスする

[LIST 9-8]
> date = new Date(2020, 2) 
Sun Mar 01 2020 00:00:00 GMT+0900 (日本標準時)
> date.setDate(32); date 
Wed Apr 01 2020 00:00:00 GMT+0900 (日本標準時)
> date.setDate(0); date 
Tue Mar 31 2020 00:00:00 GMT+0900 (日本標準時)

== 言語や地域を指定する

[LIST 9-9]
〈言語〉-〈文字体系〉-〈地域〉

== 日時の表記を国際化する

[LIST 9-10]
> date = new Date(1920, 8, 27) 
Mon Sep 27 1920 00:00:00 GMT+0900 (日本標準時)
> `${date.getFullYear()}年${date.getMonth()+1}年${date.getDate()}日` 
"1920年9年27日"

[LIST 9-11]
> date = new Date(1920, 8, 27) 
Mon Sep 27 1920 00:00:00 GMT+0900 (日本標準時)
> new Intl.DateTimeFormat("ja").format(date) 
"1920/9/27"
> new Intl.DateTimeFormat("en-US").format(date) 
"9/27/1920"
> new Intl.DateTimeFormat("en-GB").format(date) 
"27/09/1920"

[LIST 9-12]
> new Intl.DateTimeFormat(["JP", "en-GB"]).format(date) 
"27/09/1920"

[LIST 9-13]
> new Intl.DateTimeFormat(["ja-US", "en-GB"]).format(data) 
"1920/9/27"

[LIST 9-14]
> let options =  {year:"numeric", month:"numeric", day:"numeric", 
                  hour:"numeric", minute:"numeric"} 
undefined
> new Intl.DateTimeFormat("ja", options).format(date) 
"1920/9/27 0:00"

[LIST 9-15]
> new Intl.DateTimeFormat("ja-JP-u-ca-japanese").format(new Date) 
"R2/4/1"
> new Intl.DateTimeFormat("ja-JP-u-ca-japanese", {era:"long"}).format(new Date) 
"令和2/4/1"
> let options = {year:"numeric", month:"long", day:"numeric"} 
  new Intl.DateTimeFormat("ja-JP-u-ca-japanese", options).format(new Date) 
"令和2年4月1日"

== 数値の表記を国際化する

[LIST 9-16]
> new Intl.NumberFormat("en-US").format(1836.15) 
"1,836.15"
> new Intl.NumberFormat("de-DE").format(1836.15) 
"1.836,15"

[LIST 9-17]
> new Intl.NumberFormat(["JP", "de-DE"]).format(1836.15) 
"1.836,15"

[LIST 9-18]
> new Intl.NumberFormat("ja-JP-u-nu-hanidec").format(1836.15) 
"一,八三六.一五"

=== 数値の桁数を指定する

[LIST 9-19]
> new Intl.NumberFormat("ja-JP", 
    {minimumIntegerDigits:10, useGrouping:false}).format(1836.15) 
"0000001836.15"
> new Intl.NumberFormat("ja-JP", 
    {minimumIntegerDigits:5, minimumFractionDigits:5}).format(1836.15) 
"01,836.15000"

=== 通貨の表記を国際化する

[LIST 9-20]
> new Intl.NumberFormat("en-US",  
    {style:"currency", currency:"USD"}).format(1836.153) 
"$1,836.15"
> new Intl.NumberFormat("ja-JP", 
    {style:"currency", currency:"JPY"}).format(1836.153) 
"￥1,836"
> new Intl.NumberFormat("de-DE",  
    {style:"currency", currency:"JPY"}).format(1836.153) 
"1.836 ¥"
> new Intl.NumberFormat("ja-JP", 
    {style:"currency", currency:"JPY", currencyDisplay:"name"}).format(1836.153) 
"1,836円"

== 文字列の並べ替え順を国際化する

[LIST 9-21]
> german = new Intl.Collator("de") 
Collator {}
> german.compare("z", "ö") 
1
> ["z", "ä", "ö"].sort(german.compare) 
(3) ["ä", "ö", "z"]
> swedish = new Intl.Collator("sv") 
Collator {}
> swedish.compare("z", "ö") 
-1
> ["z", "ä", "ö"].sort(swedish.compare) 
(3) ["z", "ä", "ö"]

[LIST 9-22]
> new Intl.Collator("de", {sensitivity: "base"}).compare("ä", "a") 
0

[LIST 9-23]
> new Intl.Collator("en").compare(".a", "a") 
-1
> new Intl.Collator("en", {ignorePunctuation:true}).compare(".a", "a") 
0

[LIST 9-24]
> new Intl.Collator("en").compare("99", "100") 
1
> new Intl.Collator("en", {numeric:true}).compare("99", "100") 
-1

== まとめ

== 練習問題

= 非同期処理を学ぶ

[LIST 10-1]
while (true) {
  scledule(taskQueue)
  const task = taskQueue.pop()
  process(task) 
}

[LIST 10-2]
> let start = Date.now() 
  while (true) { 
    if (Date.now() - start > 10 * 1000) break 
  } 
  console.log("10秒経過") 
10秒経過

== コールバック関数

[LIST 10-3]
> document.open() 
  document.write("<button id='btn'>ボタン</button>") 
  let button = document.getElementById("btn") 

[LIST 10-4]
> let callbackFunc = () => console.log("クリックされました") 
  button.addEventListener("click", callbackFunc) 

[LIST 10-5]
> let callbackFunc = () => console.log("10秒経過") 
  setTimeout(callbackFunc, 10000) 

=== コールバック関数の問題

[LIST 10-6]
> let src = "https://www.technohippy.dev/handsonjs/ch15/ex1/JavaScript-logo.png" 
  document.write(`<img id="img" src="${src}">`) 
  let image = document.getElementById("img") 
  let callbackFunc = () => console.log("読み込みが完了しました") 
  image.addEventListener("load", callbackFunc) 

[LIST 10-7]
> let src = "https://www.technohippy.dev/handsonjs/ch15/ex1/JavaScript-logo.png" 
  document.write(`<img id="img" src="${src}">`) 
  let image = document.getElementById("img") 

[LIST 10-8]
> let callbackFunc = () => console.log("読み込みが完了しました") 
  image.addEventListener("load", callbackFunc) 

[LIST 10-9]
> if (image.complete) { 
    callbackFunc() 
  } else { 
    image.addEventListener("load", callbackFunc) 
  } 

[LIST 10-10]
> setTimeout(() => { 
    console.log("処理A") 
    setTimeout(() => { 
      console.log("処理B") 
      setTimeout(() => { 
        console.log("処理C") 
      }, Math.random() * 5000) 
    }, Math.random() * 5000) 
  }, Math.random() * 5000) 
1
処理A
処理B
処理C

== Promise

[LIST 10-11]
let promise = asyncFunc()
promise.then(callbackFunc)

[LIST 10-12]
> function waitFor(msec) { 
    return new Promise(resolve => { 
      setTimeout(resolve, msec) 
    }) 
  } 

[LIST 10-13]
> waitFor(5000).then(() => console.log("実行完了")) 
Promise {<pending>}
実行完了

[LIST 10-14]
> waitFor(Math.random() * 5000).then(() => { 
    console.log("処理A") 
    return waitFor(Math.random() * 5000) 
  }).then(() => { 
    console.log("処理B") 
    return waitFor(Math.random() * 5000) 
  }).then(() => { 
    console.log("処理C") 
  }) 
Promise {<pending>}
処理A
処理B
処理C

=== Promiseの状態

[LIST 10-15]
> promise = waitFor(1000).then(() => { 
    console.log("完了") 
    return "完了状態" 
  }) 
Promise {<pending>}
完了
> promise 
Promise {<fulfilled>: "完了状態"}

[LIST 10-16]
> promise = waitFor(1000).then(() => { 
    throw "エラー" 
  }) 
Promise {<pending>}
Promise:1 Uncaught (in promise) エラー
  Promise.then (async)
  (anonymous) @ VM5818:1
> promise 
Promise {<rejected>: "エラー"}

=== Promiseを作成する

[LIST 10-17]
new Promise((resolve, reject) => {
  // 非同期処理を行い、成功時にはresolve()を、失敗時にはreject()を呼び出す。
})

[LIST 10-18]
> function waitForAMoment(msec) { 
    return new Promise((resolve, reject) => { 
      if (msec < 2000) { 
        setTimeout(() => resolve(msec), msec) 
      } else { 
        setTimeout(() => reject(new Error("timeout")), 2000) 
      } 
    }) 
  } 

[LIST 10-19]
> waitForAMoment(1000) 
    .then(value => console.log(`成功: ${value}`)) 
    .catch(error => console.log(`失敗: ${error}`)) 
Promise {<pending>}
成功: 1000

[LIST 10-20]
> waitForAMoment(10000) 
    .then(value => console.log(`成功: ${value}`)) 
    .catch(error => console.log(`失敗: ${error}`)) 
Promise {<pending>}
失敗: Error: timeout

[LIST 10-21]
> Promise.resolve(42) 
Promise {<fulfilled>: 42}
> Promise.reject(new Error("エラー")) 
Promise {<rejected>: Error: エラー
    at <anonymous>:1:27}
Uncaught (in promise) Error: エラー
    at <anonymous>:1:27

[LIST 10-22]
> promise1 = new Promise(() => {}) 
Promise {<pending>}
> promise2 = Promise.resolve(promise1) 
Promise {<pending>}
> promise1 === promise2 
true

[LIST 10-23]
> thenable = { 
    then(resolve) { 
      resolve(42) 
    } 
  } 
{then: ƒ}
> Promise.resolve(thenable) 
Promise {<fulfilled>: 42}

=== 完了時の処理を記述する

[LIST 10-24]
> Promise.resolve(42) 
    .then(value => `成功:${value}`, error => error) 
Promise {<fulfilled>: "成功:42"}
> Promise.reject(new Error("失敗")) 
    .then(value => `成功:${value}`, error => error) 
Promise {<fulfilled>: Error: 失敗
    at <anonymous>:1:16}

[LIST 10-25]
> Promise.resolve().then(() => Promise.resolve(42)) 
Promise {<fulfilled>: 42}

[LIST 10-26]
then(resolve, reject) {
  try {
    return Promise.resolve(resolve(this.executor()))
  } catch (error) {
    return Promise.resolve(reject(error))
  }
}

[LIST 10-27]
> Promise.reject() 
    .then(() => console.log("成功1"), () => console.log("エラー1")) 
    .then(() => console.log("成功2"), () => console.log("エラー2")) 
エラー1
成功2
Promise {<fulfilled>: undefined}

[LIST 10-28]
> Promise.reject() 
    .then(() => console.log("成功1"), () => { 
      console.log("エラー1") 
      throw "エラー1" 
    }) 
    .then(() => console.log("成功2"), () => { 
      console.log("エラー2") 
      return Promise.reject("エラー2") 
    }) 
    .then(() => console.log("成功3"), () => { 
      console.log("エラー3") 
    }) 
エラー1
エラー2
エラー3
Promise {<fulfilled>: undefined}

[LIST 10-29]
> Promise.reject(new Error("error")).catch(err => console.log(err)) 
Error: error
    at <anonymous>:1:16
Promise {<fulfilled>: undefined}

[LIST 10-30]
> Promise.resolve(42).finally(() => console.log("完了")) 
完了
Promise {<fulfilled>: 42}
> Promise.reject(new Error("error")).finally(() => console.log("完了")) 
完了
Promise {<rejected>: Error: error
    at <anonymous>:1:16}
Uncaught (in promise) Error: error
    at <anonymous>:1:16

[LIST 10-31]
> Promise.resolve(42) 
    .then(() => console.log("一番目の処理")) 
    .then(() => { 
      console.log("二番目の処理（失敗）") 
      return Promise.reject() 
    }) 
    .then(() => console.log("三番目の処理")) 
    .catch(() => console.log("エラー処理")) 
    .finally(() => console.log("終了処理")) 
一番目の処理
二番目の処理（失敗）
エラー処理
終了処理
Promise {<fulfilled>: undefined}

[LIST 10-32]
> Promise.resolve().then(() => console.log("Promise内")) 
  console.log("Promise後") 
Promise後
Promise内

=== 複数の非同期処理をまとめて扱う

[LIST 10-33]
function lagResolve(msec) {
  return new Promise(resolve => {
    setTimeout(() => resolve(`成功:${msec}`), msec)
  })
}

function lagReject(msec) {
  return new Promise((_, reject) => {
    setTimeout(() => reject(new Error(`失敗:${msec}`)), msec)
  })
}

[LIST 10-34]
> Promise.all([lagResolve(1000), lagResolve(5000), lagResolve(4000)]) 
    .then(result => console.log(result)) 
Promise {<pending>}
(3) ["成功:1000", "成功:5000", "成功:4000"]

[LIST 10-35]
> Promise.all([lagReject(1000), lagResolve(5000), lagResolve(4000)]) 
    .catch(result => console.log(result)) 
Promise {<pending>}
Error: 失敗:1000
    at <anonymous>:3:29

[LIST 10-36]
> Promise.allSettled([lagReject(1000), lagResolve(5000), lagResolve(4000)]) 
    .then(result => console.log(result)) 
Promise {<pending>}
(3) [{…}, {…}, {…}]
  0: {status: "rejected", reason: Error: 失敗:1000 at <anonymous>:3:29}
  1: {status: "fulfilled", value: "成功:5000"}
  2: {status: "fulfilled", value: "成功:4000"}
  length: 3
  __proto__: Array(0)

[LIST 10-37]
> Promise.race([lagResolve(1000), lagResolve(5000), lagResolve(4000)]) 
    .then(result => console.log(result)) 
Promise {<pending>}
成功:1000

[LIST 10-38]
> Promise.race([lagResolve(1000), lagReject(5000), lagReject(4000)]) 
    .then(result => console.log(result)) 
Promise {<pending>}
成功:1000

[LIST 10-39]
> Promise.race([lagReject(1000), lagResolve(5000), lagResolve(4000)]) 
    .catch(result => console.log(result)) 
Promise {<pending>}
Error: 失敗:1000
    at <anonymous>:3:29

[LIST 10-40]
> Promise.race([ 
    Promise.all([lagResolve(1000), lagResolve(5000), lagResolve(4000)]), 
    Promise.all([lagResolve(6000), lagResolve(500), lagResolve(100)]) 
  ]).then(result => console.log(result)) 
Promise {<pending>}
(3) ["成功:1000", "成功:5000", "成功:4000"]

=== 非同期処理を同期処理のように記述する

[LIST 10-41]
> async function answer() { 
    return 42 
  } 
undefined
> promise = answer() 
Promise {<fulfilled>: 42}
> promise.then(result => console.log(result)) 
42
Promise {<fulfilled>: undefined}

[LIST 10-42]
> async function raise() { 
    throw new Error("エラー") 
  } 
undefined
> promise = raise() 
Promise {<rejected>: Error: エラー
    at raise (<anonymous>:2:11)
    at <anonymous>:1:11}
Uncaught (in promise) Error: エラー
    at raise (<anonymous>:2:11)
    at <anonymous>:1:11
raise       @ VM132:2
(anonymous) @ VM139:1

[LIST 10-43]
> functionExp = async function() { 
    return 42 
  } 
async ƒ () {
  return 42
}
> functionExp() 
Promise {<fulfilled>: 42}

[LIST 10-44]
> arrowFunc = async () => 42 
async () => 42
> arrowFunc() 
Promise {<fulfilled>: 42}

[LIST 10-45]
> class Klass { 
    async functionMethod() { 
      return 42 
    } 
  } 
undefined
> new Klass().functionMethod() 
Promise {<fulfilled>: 42}

[LIST 10-46]
> function waitFor(msec) { 
    return new Promise((resolve, reject) => { 
      setTimeout(() => resolve("Tick"), msec) 
    }) 
  } 
undefined
> async function count(num) { 
    for (let i = num; 0 <= i; i--) { 
      const tick = await waitFor(1000) 
      console.log(tick, i) 
    } 
  } 
undefined
> count(3) 
Promise {<pending>}
Tick 3
Tick 2
Tick 1
Tick 0

[LIST 10-47]
async function showHtml(url) {
  try {
    const google = await fetch(url)
    const body = await google.text()
    console.log("本文表示", body)
  } catch (err) {
    console.warn("エラー表示", err)
  }
}

[LIST 10-48]
> showHtml("https://www.google.com") 
Promise {<pending>}
本文表示 <!doctype html><html itemscope="" itemtype="http://schema.org/Web...

[LIST 10-49]
> showHtml("https://twitter.com") 
Promise {<pending>}
(index):1 Access to fetch at 'https://twitter.com/' from origin 'https://www.
google.com' has been blocked by CORS policy: No 'Access-Control-Allow-Origin'
header is present on the requested resource. If an opaque response serves you
r needs, set the request's mode to 'no-cors' to fetch the resource with CORS
disabled.
GET https://twitter.com/ net::ERR_FAILED
  showHtml @ VM5234:3
  (anonymous) @ VM5261:1
エラー表示 TypeError: Failed to fetch
  showHtml @ VM5234:7
  async function (async)
  showHtml @ VM5234:3
  (anonymous) @ VM5261:1

=== 非同期処理を繰り返す

[LIST 10-50]
const { value, done } = iterator.next()

[LIST 10-51]
const { value, done } = await asyncIterator.next()

[LIST 10-52]
> let fizzBuzzAsyncIterator = { 
    count: 0, 
    max: 7, 
    async next() { 
      await new Promise(resolve => setTimeout(resolve, 1000)) 
      this.count++ 
      const done = this.max < this.count 
      if (this.count % 6 === 0) { 
        return {value:"FizzBuzz", done} 
      } else if (this.count % 2 === 0) { 
        return {value:"Fizz", done} 
      } else if (this.count % 3 === 0) { 
        return {value:"Buzz", done} 
      } else { 
        return {value:this.count, done} 
      } 
    } 
  } 

[LIST 10-53]
> let fizzBuzzAsyncIterable = { 
    [Symbol.asyncIterator]() { 
      return fizzBuzzAsyncIterator 
    } 
  } 

[LIST 10-54]
> for await (let value of fizzBuzzAsyncIterable) { 
    console.log(value) 
  } 
1
Fizz
Buzz
Fizz
5
FizzBuzz
7
undefined

[LIST 10-55]
> async function* makeFizzBuzzAsyncGenerator(max) { 
    for (let count = 1; count <= max; count++) { 
      await new Promise(resolve => setTimeout(resolve, 1000)) 
      if (count % 6 === 0) { 
        yield "FizzBuzz" 
      } else if (count % 2 === 0) { 
        yield "Fizz" 
      } else if (count % 3 === 0) { 
        yield "Buzz" 
      } else { 
        yield count 
      } 
    } 
  } 

[LIST 10-56]
> for await (let value of makeFizzBuzzAsyncGenerator(7)) { 
    console.log(value) 
  } 
1
Fizz
Buzz
Fizz
5
FizzBuzz
7
undefined

== まとめ

== 練習問題

[LIST 10-57]
Promise.resolve(42)
  .then(() => console.log("FIRST"))
  .catch(() => console.log("first catch"))
  .then(() => console.log("SECOND"))
  .then(() => {
      console.log("FIRST ERROR")
      return Promise.reject()
  })
  .then(() => "third")
  .then(() => console.log("fourth"))
  .catch(() => console.log("SECOND CATCH"))
  .then(() => console.log("FIFTH"))
  .catch(() => console.log("third catch"))
  .finally(() => console.log("FIRST FINALLY"))

= メタプログラミングを学ぶ

[LIST 11-1]
let n1 = 6
let n2 = 7
let n3 = n1 * n2

[LIST 11-2]
> let adder = new Function(..."abc", "return a+b+c") 

[LIST 11-3]
> adder(1, 16, 25) 
42

[LIST 11-4]
> adder.toString() 
"function anonymous(a,b,c
) {
return a+b+c
}"

[LIST 11-5]
> let code = adder.toString() 
undefined
> args = code.match(/\(([\s\S]+)\)/m)[1].trim().split(",") 
(3) ["a", "b", "c"]
> body = code.match(/\\{([\s\S]+)\\}/m)[1].trim().replace(/[+]/g, "*") 
"return a*b*c"
> multiplier = new Function(args, body) 
ƒ anonymous(a,b,c
) {
return a*b*c
}
> multiplier(1, 16, 25) 
400

== Proxy

=== プロキシを作成する

[LIST 11-6]
> array = [3, 4, 5] 
(3) [3, 4, 5]
> arrayProxy = new Proxy(array, {}) 
Proxy {0: 3, 1: 4, 2: 5}
> arrayProxy[1] 
4
> arrayProxy.length 
3

[LIST 11-7]
> arrayProxy[0] = 1 
1
> arrayProxy 
Proxy {0: 1, 1: 4, 2: 5}
> array 
(3) [1, 4, 5]

[LIST 11-8]
> arrayProxy.map(n => n * n).reduce((s, n) => s + n, 0) 
42

=== プロパティアクセスをプロキシする

[LIST 11-9]
> array = [3.14, 9.8, 2.718] 
(3) [3.14, 9.8, 2.718]
> arrayProxy = new Proxy(array, { 
    get(target, prop) { 
      return Math.round(target[prop]) 
    }, 
    set(target, prop, value) { 
      if (!Number.isInteger(value)) { 
        throw new Error("not integer") 
      } 
      target[prop] = value 
    }, 
    has(target, prop) { 
      return prop < 2 
    }, 
    ownKeys(target) { 
      return ["0", "1", "length"] 
    } 
  }) 
Proxy {0: 3.14, 1: 9.8, 2: 2.718}

[LIST 11-10]
> arrayProxy[0] 
3
> arrayProxy[1] 
10
> arrayProxy[3] = 8.31 
Uncaught Error: not integer
    at Object.set (<anonymous>:7:15)
    at <anonymous>:1:15
> arrayProxy[3] = 365 
365
> array 
(4) [3.14, 9.8, 2.718, 365]

[LIST 11-11]
> 0 in arrayProxy 
true
> 1 in arrayProxy 
true
> 2 in arrayProxy 
false
> Object.getOwnPropertyNames(arrayProxy) 
(3) ["0", "1", "length"]

[LIST 11-12]
> arrayProxy[2] 
3

[LIST 11-13]
> "length" in arrayProxy 
Uncaught TypeError: 'has' on proxy: trap returned falsish for property
'length' which exists in the proxy target as non-configurable
    at <anonymous>:1:10

[LIST 11-14]
> Object.getOwnPropertyDescriptor(array, "length") 
{value: 4, writable: true, enumerable: false, configurable: false}

=== 関数やコンストラクタの呼び出しをプロキシする

[LIST 11-15]
> function add(a, b, c) { 
    return a + b + c 
  } 
undefined
> add(1, 4 ,5) 
10

[LIST 11-16]
> addProxy = new Proxy(add, { 
    apply(target, thisArg, args) { 
      return target.apply(thisArg, args.map(n => n * n)) 
    } 
  }) 
Proxy {length: 3, name: "add", arguments: null, caller: null, prototype: {…}}
> addProxy(1, 4 ,5) 
42

[LIST 11-17]
> array = [..."WRYYYY"] 
(6) ["W", "R", "Y", "Y", "Y", "Y"]
> array.join = new Proxy(Array.prototype.join, { 
    apply(target, thisArg, args) { 
      return target.apply(thisArg, ["!"]) 
    } 
  }) 
Proxy {length: 1, name: "join"}
> array.join() 
"W!R!Y!Y!Y!Y"

[LIST 11-18]
> invalidProxy = new Proxy({}, { 
    apply(target, thisArg, args) { 
      return 0 
    } 
  }) 
Proxy {}
> invalidProxy() 
Uncaught TypeError: invalidProxy is not a function
    at <anonymous>:1:1

[LIST 11-19]
> BetterArray = new Proxy(Array, { 
    construct(target, args) { 
      if (args.length === 1) { 
        return [args[0]] 
      } 
      return new target(...args) 
    } 
  }) 
Proxy {length: 1, name: "Array", prototype: Array(0), isArray: ƒ, …}
> new BetterArray(3) 
[3]
> new Array(3) 
(3) [empty × 3]

[LIST 11-20]
> InvalidNumber = new Proxy(Number, { 
    construct(target, args) { 
      return 0 
    } 
  }) 
Proxy {length: 1, name: "Number", prototype: Number, isFinite: ƒ, …}
> new InvalidNumber() 
Uncaught TypeError: 'construct' on proxy: trap returned non-object ('0')
    at <anonymous>:1:1

=== 拡張可能性へのアクセスをプロキシする

[LIST 11-21]
> extensionProxy = new Proxy({}, { 
    isExtensible(target) { 
      console.log("isExtensibleに割り込み") 
      return Object.isExtensible(target) 
    }, 
    preventExtensions(target) { 
      console.log("preventExtensionsに割り込み") 
      return Object.preventExtensions(target) 
    } 
  }) 
Proxy {}
> Object.isExtensible(extensionProxy) 
isExtensibleに割り込み
true
> Object.preventExtensions(extensionProxy) 
preventExtensionsに割り込み
Proxy {}

=== プロパティ定義へのアクセスをプロキシする

[LIST 11-22]
> obj = {} 
{}
> defineProxy = new Proxy(obj, { 
    defineProperty(target, property, descriptor) { 
      console.log(`プロパティ定義:${property}`) 
      return true 
    }, 
    getOwnPropertyDescriptor(target, property) { 
      console.log(`プロパティ記述子取得:${property}`) 
      return {value:42, writable:true, enumerable:true, configurable:true} 
    }, 
    deleteProperty(target, property) { 
      console.log(`プロパティ削除:${property}`) 
      return true 
    } 
  }) 
Proxy {}

[LIST 11-23]
> Object.defineProperty(defineProxy, "prop1", {}) 
プロパティ定義:prop1
Proxy {}
> Object.defineProperties(defineProxy, {"prop2":{}, "prop3":{}}) 
プロパティ定義:prop2
プロパティ定義:prop3
Proxy {}

[LIST 11-24]
> Object.getOwnPropertyDescriptor(defineProxy, "prop") 
プロパティ記述子取得:prop
{value: 42, writable: true, enumerable: true, configurable: true}

[LIST 11-25]
> defineProxy.prop 
undefined

[LIST 11-26]
> delete defineProxy.prop 
プロパティ削除:prop
true

=== 取り消し可能なProxyを作成する

[LIST 11-27]
> target = {val: 42} 
{val: 42}
> let { proxy, revoke } = Proxy.revocable(target, {}) 
undefined
> proxy 
Proxy {val: 42}
> revoke 
ƒ () { [native code] }

[LIST 11-28]
> proxy.val 
42
> revoke() 
undefined
> proxy.val 
Uncaught TypeError: Cannot perform 'get' on a proxy that has been revoked
    at <anonymous>:1:7

[LIST 11-29]
> target 
{val: 42}

== Reflect

=== トラップの実装に利用する

[LIST 11-30]
> let arrayLike = {0:3.14, 1:9.8, 2:2.718, length:3} 
undefined
> arrayProxy = new Proxy(arrayLike, { 
    get(target, prop) { 
      if (prop in target) { 
        return Reflect.get(target, prop) 
      } else { 
        return Reflect.get(Array.prototype, prop) 
      } 
    }, 
    set(target, prop, value) { 
      return Reflect.set(target, prop, value) 
    } 
  }) 
Proxy {0: 3.14, 1: 9.8, 2: 2.718, length: 3}

[LIST 11-31]
> arrayProxy[0] 
3.14
> arrayProxy[1] = 8.31 
8.31
> arrayProxy 
Proxy {0: 3.14, 1: 8.31, 2: 2.718, length: 3}
> arrayProxy.reverse() 
Proxy {0: 2.718, 1: 8.31, 2: 3.14, length: 3}
> arrayLike 
{0: 2.718, 1: 8.31, 2: 3.14, length: 3}

=== 単独で利用する

[LIST 11-32]
> Function.prototype.apply.call(Math.floor, undefined, [3.14]) 
3
> Reflect.apply(Math.floor, undefined, [3.14]) 
3

== まとめ

== 練習問題

[LIST 11-33]
let extendNumber = num => new Proxy(〈この部分を追加〉)
let en = extendNumber(3.14)
en.round()    // => 3
en.ceil()     // => 4
en.pow(2)     // => 9.8596
en.toString() // => "3.14"

= Webを学ぶ

== Web（ウェブ）

=== HTML

[LIST 12-1]
<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8">
    <title>ウェブ</title>
  </head>
  <body>
    <section id="html" class="note">
      <h1>HTML</h1>
      <p><strong>HTML</strong>は文書のコンテンツと構造を表現します。</p>
    </section>
    <section id="css" class="note">
      <h1>CSS</h1>
      <p><strong>CSS</strong>はHTMLのスタイルを指定します。</p>
    </section>
    <section id="js" class="note">
      <h1>JavaScript</h1>
      <p><strong>JavaScript</strong>はHTMLとCSSの両方を制御できます。</p>
    </section>
  </body>
</html>

=== CSS

[LIST 12-2]
h1 {
  background:black;
  color:white;
  margin:10px;
  padding:10px;
}
p {
  border:1px solid gray;
  margin:10px;
  padding:5px;
}
strong {
  color:red;
  font-size:1.5em;
}

[LIST 12-3]
<link href="style.css" rel="stylesheet">

=== JavaScript

[LIST 12-4]
<script>
document.body.addEventListener("click", function() {
  this.style.filter = this.style.filter ? "" : "blur(5px)"
})
</script>

[LIST 12-5]
<script src="blur.js"></script>

== グローバルオブジェクト

[LIST 12-6]
> globalThis.document 
#document

[LIST 12-7]
> globalThis === window 
true
> window.document 
#document
> window 
Window {parent: Window, opener: null, top: Window, length: 0, …}

=== console

=== location

[LIST 12-8]
> location.href = "https://www.google.com/" 

=== navigator

[LIST 12-9]
> navigator.appName 
"Netscape"
> navigator.appVersion 
"5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, ..."
> navigator.language 
"ja-JP"
> navigator.connection 
NetworkInformation {onchange: null, effectiveType: "4g", rtt: 100, ...}
> navigator.onLine 
true

== ドキュメントオブジェクトモデル

=== DOMの構造

[LIST 12-10]
> document 
#document

[LIST 12-11]
> Object.getPrototypeOf(document) 
HTMLDocument {Symbol(Symbol.toStringTag): "HTMLDocument", constructor: ƒ}

[LIST 12-12]
> document.childNodes[0] 
<!DOCTYPE html>
> Object.getPrototypeOf(document.childNodes[0]) 
DocumentType {before: ƒ, after: ƒ, …}

[LIST 12-13]
> document.childNodes[1] 
<html lang="ja">
...省略
> Object.getPrototypeOf(document.childNodes[1]) 
HTMLHtmlElement {Symbol(Symbol.toStringTag): "HTMLHtmlElement", constructor: ƒ}

[LIST 12-14]
> document.childNodes[1].childNodes[0] 
<head>…</head>
> Object.getPrototypeOf(document.childNodes[1].childNodes[0]) 
HTMLHeadElement {Symbol(Symbol.toStringTag): "HTMLHeadElement", constructor: ƒ}

[LIST 12-15]
> document.childNodes[1].childNodes[1] 
#text
> Object.getPrototypeOf(document.childNodes[1].childNodes[1]) 
Text {Symbol(Symbol.toStringTag): "Text", splitText: ƒ, constructor: ƒ}

[LIST 12-16]
> document.childNodes[1].childNodes[2] 
<body>…</body>
> Object.getPrototypeOf(document.childNodes[1].childNodes[2]) 
HTMLBodyElement {…}

[LIST 12-17]
> document.childNodes[1].childNodes[2].childNodes[1] 
<section id="html" class="note">…</section>
> Object.getPrototypeOf(document.childNodes[1].childNodes[2].childNodes[1]) 
HTMLElement {…}

[LIST 12-18]
> document.childNodes[1].childNodes[2].style.background = "black" 
"black"

[LIST 12-19]
> document.body.style.background = "white" 
"white"

=== 主要なオブジェクト

=== 要素の階層をたどる

[LIST 12-20]
> document.body.getRootNode() 
#document

[LIST 12-21]
> document.body.childNodes 
NodeList(9) [text, section#html.note, text, section#css.note, text, ...]
> document.body.children 
HTMLCollection(3) [section#html.note, section#css.note, section#js.note, ...]

[LIST 12-22]
> document.body.children.html 
<section id="html" class="note">…</section>
> document.body.children.css 
<section id="css" class="note">…</section>

[LIST 12-23]
> document.body.firstChild 
#text
> document.body.firstElementChild 
<section id="html" class="note">…</section>
> document.body.children.css.previousSibling 
#text
> document.body.children.css.previousElementSibling 
<section id="html" class="note">…</section>

=== 要素を検索する

[LIST 12-24]
> document.getElementsByTagName("strong") 
HTMLCollection(3) [strong, strong, strong]

[LIST 12-25]
> document.body.children.css.getElementsByTagName("strong") 
HTMLCollection [strong]

[LIST 12-26]
> document.getElementById("js") 
<section id="js" class="note">…</section>

[LIST 12-27]
> document.getElementsByClassName("note") 
HTMLCollection(3) [section#html.note, section#css.note, section#js.note, ...]
> document.body.getElementsByClassName("note") 
HTMLCollection(3) [section#html.note, section#css.note, section#js.note, ...]

[LIST 12-28]
> document.querySelector("meta[charset=UTF-8]") 
<meta charset="UTF-8">
> document.querySelectorAll(".note h1") 
NodeList(3) [h1, h1, h1]
> document.body.querySelectorAll(".note p") 
NodeList(3) [p, p, p]

=== 要素の情報を調べる

[LIST 12-29]
> document.nodeType 
9
> document.nodeType === Node.DOCUMENT_NODE 
true
> document.body.nodeType 
1
> document.body.nodeType === Node.ELEMENT_NODE 
true

[LIST 12-30]
> document.nodeName 
"#document"
> document.tagName 
undefined
> document.body.nodeName 
"BODY"
> document.body.tagName 
"BODY"

=== 要素の属性を操作する

[LIST 12-31]
> js = document.getElementById("js") 
<section id="js" class="note">…</section>
> js.id 
"js"
> js.id = "javascript" 
"javascript"
> js 
<section id="javascript" class="note">…</section>

[LIST 12-32]
> document.getElementById("js") 
null
> document.getElementById("javascript") 
<section id="javascript" class="note">…</section>

[LIST 12-33]
> document.body.children.css.className 
"note"

[LIST 12-34]
> css = document.body.children.css 
<section id="css" class="note">…</section>
> css.className += " stylesheet" 
"note stylesheet"
> css 
<section id="css" class="note stylesheet">…</section>

[LIST 12-35]
> css.className.split(" ") 
(2) ["note", "stylesheet"]
> css.className.split(" ").includes("stylesheet") 
true

[LIST 12-36]
> css.classList 
DOMTokenList(2) ["note", "stylesheet", value: "note stylesheet"]
> css.classList.add("css") 
undefined
> css.classList 
DOMTokenList(3) ["note", "stylesheet", "css", value: "note stylesheet css"]

[LIST 12-37]
> document.head.firstElementChild.attributes 
NamedNodeMap {0: charset, charset: charset, length: 1}

[LIST 12-38]
> charset = document.head.firstElementChild.attributes[0] 
charset="UTF-8"
> charset.name 
"charset"
> charset.value 
"UTF-8"

[LIST 12-39]
> document.head.firstElementChild.getAttributeNames() 
["charset"]

[LIST 12-40]
> meta = document.head.firstElementChild 
<meta charset="UTF-8">
> meta.hasAttribute("charset") 
true
> meta.getAttribute("charset") 
"UTF-8"
> meta.setAttribute("charset", "utf8") 
undefined
> meta 
<meta charset="utf8">
> meta.removeAttribute("charset") 
undefined
> meta 
<meta>

=== 要素のコンテンツを操作する

[LIST 12-41]
> document.querySelector("strong").style.display = "none" 
"none"

[LIST 12-42]
> htmlNote = document.querySelector("p") 
<p>…</p>
> htmlNote.textContent 
"HTMLは文書のコンテンツと構造を表現します。"
> htmlNote.innerText 
"は文書のコンテンツと構造を表現します。"

[LIST 12-43]
> htmlNote.textContent = "HTMLは文書のコンテンツと構造を表現します。" 
"HTMLは文書のコンテンツと構造を表現します。"
> htmlNote 
<p>HTMLは文書のコンテンツと構造を表現します。</p>

=== 要素を削除する

[LIST 12-44]
> node = document.body.firstElementChild 
<section id="html" class="note">…</section>
> node.parentNode.removeChild(node) 
<section id="html" class="note">…</section>

=== 要素を追加する

[LIST 12-45]
> document.createElement("div") 
<div></div>
> document.createTextNode("HTML") 
"HTML"

[LIST 12-46]
> let body = document.body 
undefined
> body.insertBefore( 
    document.createTextNode("insertBefore(js)"), body.children.js) 
"insertBefore(js)"
> body.appendChild(document.createTextNode("appendChild")) 
"appendChild"
> body.append(document.createElement("hr"), "append") 
undefined
> body.prepend("prepend", document.createElement("hr")) 
undefined

[LIST 12-47]
> let fragment = new DocumentFragment() 
  fragment.appendChild(document.createElement("hr")) 
  fragment.appendChild(document.createElement("hr")) 
  fragment.appendChild(document.createElement("hr")) 
  fragment.appendChild(document.createElement("hr")) 
  document.body.appendChild(fragment) 

=== 要素を入れ替える

[LIST 12-48]
> document.body.replaceChild(document.createElement("hr"), 
    document.body.children.css) 
<section id="css" class="note">…</section>

[LIST 12-49]
> document.body.contentEditable = true 

[LIST 12-50]
> document.execCommand("cut") 

[LIST 12-51]
> document.execCommand("undo") 

== CSSオブジェクトモデル

[LIST 12-52]
> document.body.style.background = "gray" 
"gray"
> document.body.style.fontSize = "200%" 
"200%"

[LIST 12-53]
h1 {
  background:black;
  color:white;
  margin:10px;
  padding:10px;
}
p {
  border:1px solid gray;
  margin:10px;
  padding:5px;
}
strong {
  color:red;
  font-size:1.5em;
}

[LIST 12-54]
> document.styleSheets[0].cssRules 
CSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, length: 3}
  0: CSSStyleRule {selectorText: "h1", style: CSSStyleDeclaration, ...
  1: CSSStyleRule {selectorText: "p", style: CSSStyleDeclaration, ...
  2: CSSStyleRule {selectorText: "strong", style: CSSStyleDeclaration, ...
  length: 3
  __proto__: CSSRuleList

=== 主要なオブジェクト

=== ルールを確認する

[LIST 12-55]
> document.styleSheets[0].cssRules 
CSSRuleList {0: CSSStyleRule, 1: CSSStyleRule, 2: CSSStyleRule, length: 3}
> document.styleSheets[0].cssRules[0] 
CSSStyleRule {selectorText: "h1", style: CSSStyleDeclaration, ...

[LIST 12-56]
> document.styleSheets[0].cssRules[0].selectorText 
"h1"
> document.styleSheets[0].cssRules[0].style 
CSSStyleDeclaration {0: "background-image", 1: "background-position-x", ...,
  alignContent: "", alignItems: "", alignSelf: "", alignmentBaseline: "", ...}

[LIST 12-57]
> for (let rule of document.styleSheets[0].cssRules) { 
    const selector = rule.selectorText 
    for (let prop of rule.style) { 
      console.log(`${selector} { ${prop}:${rule.style[prop]} }`) 
    } 
  } 
h1 { background-image:initial }
h1 { background-position-x:initial }
h1 { background-position-y:initial }
h1 { background-size:initial }
h1 { background-repeat-x:initial }
h1 { background-repeat-y:initial }
h1 { background-attachment:initial }
h1 { background-origin:initial }
h1 { background-clip:initial }
h1 { background-color:black }
h1 { color:white }
h1 { margin-top:10px }
h1 { margin-right:10px }
  :
p { padding-bottom:5px }
p { padding-left:5px }
strong { color:red }
strong { font-size:1.5em }

=== ルールを書き換える

[LIST 12-58]
> let h1Style = document.styleSheets[0].cssRules[0].style 
undefined
> h1Style.fontSize = "50%" 
"50%"
> h1Style.setProperty("font-size", "300%", "important") 
undefined
> h1Style.removeProperty("font-size") 
"300%"

[LIST 12-59]
> document.styleSheets[0].cssRules[0].selectorText = ".note" 

=== 新しいルールを追加する

[LIST 12-60]
> document.styleSheets[0].insertRule(` 
    .note { 
      margin:4px; 
      border:1px solid black; 
      background-color:lightYellow; 
    }`) 
0

[LIST 12-61]
> document.styleSheets[0].insertRule("body { color: red } h1 { color: red }") 
Uncaught DOMException: Failed to execute 'insertRule' on ...

=== 既存のルールを削除する

[LIST 12-62]
> document.styleSheets[0].deleteRule(0) 

== イベント

[LIST 12-63]
document.body.addEventListener("click", evt => {
  evt.target.style.backgroundColor =
    `#${Math.floor(Math.random() * 0xffffff).toString(16)}`
})

=== イベントを処理する

[LIST 12-64]
> document.body.addEventListener("click",  
    () => console.log("最初のイベントハンドラ")) 
undefined
> let secondHandler = () => console.log("2つ目のイベントハンドラ") 
undefined
> document.body.addEventListener("click", secondHandler) 
undefined

[LIST 12-65]
> document.body.dispatchEvent(new Event("click")) 
最初のイベントハンドラ
2つ目のイベントハンドラ
true

[LIST 12-66]
> document.body.removeEventListener("click", secondHandler) 
undefined
> document.body.dispatchEvent(new Event("click")) 
最初のイベントハンドラ
true

=== 代表的なイベントを使用する

==== キーボードイベント

[LIST 12-67]
> let keyLogger = evt => console.log( 
  `type:${evt.type} 
  code:${evt.code} 
  key:${evt.key} 
  shift:${evt.shiftKey} 
  `) 
undefined
> document.addEventListener("keydown", keyLogger) 
undefined
> document.addEventListener("keyup", keyLogger) 
undefined

[LIST 12-68]
type:keydown
code:KeyA
key:a
shift:false

type:keyup
code:KeyA
key:a
shift:false

type:keydown
code:ShiftRight
key:Shift
shift:true

type:keydown
code:KeyA
key:A
shift:true

type:keyup
code:KeyA
key:A
shift:true

type:keyup
code:ShiftRight
key:Shift
shift:false

==== マウスイベント

[LIST 12-69]
> let clicking = false 
  document.addEventListener("mousedown", () => clicking = true) 
  document.addEventListener("mouseup", () => clicking = false) 
  document.addEventListener("mousemove", evt => { 
    if (!clicking) return 
    console.log( 
  `clientX: ${evt.clientX} 
  clientY: ${evt.clientY} 
  shiftKey: ${evt.shiftKey} 
  `) 
  }) 

[LIST 12-70]
clientX: 335
clientY: 277
shiftKey: false

clientX: 337
clientY: 277
shiftKey: true

=== イベントを作成する

[LIST 12-71]
> let callEvent = new CustomEvent("call", {detail: "もしもし私メリーさん"}) 
undefined
> document.addEventListener("call", evt => console.log(evt.detail)) 
undefined
> document.dispatchEvent(callEvent) 
もしもし私メリーさん
true

=== イベントハンドラの探索順序を理解する

[LIST 12-72]
> document.body.addEventListener("click", evt => { 
    evt.target.style.backgroundColor = 
      `#${Math.floor(Math.random() * 0xffffff).toString(16)}` 
  }) 

[LIST 12-73]
> window.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} bubble window`)) 
  window.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} capture window`), true) 
  document.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} bubble document`)) 
  document.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} capture document`), true) 
  document.body.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} bubble body`)) 
  document.body.addEventListener("click",  
    evt => console.log(`Ph.${evt.eventPhase} capture body`), true) 

[LIST 12-74]
Ph.1 capture window
Ph.1 capture document
Ph.2 bubble body
Ph.2 capture body
Ph.3 bubble document
Ph.3 bubble window

==== イベントの伝播を止める

[LIST 12-75]
> window.addEventListener("click", evt => evt.stopPropagation(), true) 

[LIST 12-76]
Ph.1 capture window

==== イベントのデフォルトの動作を止める

[LIST 12-77]
> let as = document.getElementsByTagName("a") 
undefined
> for (let i = 0; i < as.length; i++) { 
    as[i].addEventListener("click", evt => evt.preventDefault()) 
  } 
undefined

== Web Components

=== Custom Elements

[LIST 12-78]
class InfoPanel extends HTMLElement {
  constructor() {
    super()
  }
}

[LIST 12-79]
customElements.define("info-panel", InfoPanel)

[LIST 12-80]
> let infoPanel = document.createElement("info-panel") 
undefined
> document.body.appendChild(infoPanel) 
<info-panel></info-panel>
> infoPanel.style.border = "1px solid blue" 
  infoPanel.style.display = "block" 
  infoPanel.style.height = "5px" 
"5px"

=== Shadow DOM

[LIST 12-81]
class InfoPanel extends HTMLElement {
  constructor() {
    super()
    const shadow = this.attachShadow({mode: "open"}) 
    shadow.append("Black Sabbath") 
  }
}

[LIST 12-82]
> customElements.define("info-panel", InfoPanel) 
undefined
> let infoPanel = document.createElement("info-panel") 
undefined
> document.body.appendChild(infoPanel) 
<info-panel>…</info-panel>

[LIST 12-83]
class InfoPanel extends HTMLElement {
  constructor() {
    super()

    let style = document.createElement("style")
    style.textContent = `
      .info-panel {
        margin: 10px;
        padding: 10px;
        border: 1px solid gray;
      }
      dt {
        width: 120px;
        float: left;
      }`

    let panel = document.createElement("div")
    panel.classList.add("info-panel")
    panel.innerHTML = `
      <h1>${this.getAttribute("name")}</h1>
      <dl>
        <dt>Power</dt><dd>${this.getAttribute("power")}</dd>
        <dt>Speed</dt><dd>${this.getAttribute("speed")}</dd>
        <dt>Range</dt><dd>${this.getAttribute("range")}</dd>
      </dl>`

    const shadow = this.attachShadow({mode: "open"})
    shadow.append(style, panel)
  }
}

[LIST 12-84]
> customElements.define("info-panel", InfoPanel) 
undefined
> let div = document.createElement("div") 
  div.innerHTML = ` 
    <info-panel name="Black Sabbath" power="E" speed="A" range="A"> 
    </info-panel>` 
  document.body.append(div) 

=== HTML Template

[LIST 12-85]
<template id="info-panel-template">
  <style>
    .info-panel {
      margin: 10px;
      padding: 10px;
      border: 1px solid gray;
    }
    dt {
      width: 120px;
      float: left;
    }
  </style>
  <div class="info-panel">
    <h1 id="name"></h1>
    <dl>
      <dt>Power</dt><dd id="power"></dd>
      <dt>Speed</dt><dd id="speed"></dd>
      <dt>Range</dt><dd id="range"></dd>
    </dl>
  </div>
</template>

[LIST 12-86]
class InfoPanel extends HTMLElement {
  constructor() {
    super()
    const template = document.getElementById("info-panel-template")
    const content = template.content.cloneNode(true); // セミコロン
    ["name", "power", "speed", "range"].forEach(id => 
      content.getElementById(id).textContent = this.getAttribute(id))

    const shadow = this.attachShadow({mode: "open"})
    shadow.append(content)
  }
}

[LIST 12-87]
<info-panel name="Black Sabbath" power="E" speed="A" range="A"></info-panel>

== まとめ

== 練習問題

[LIST 12-88]
document.styleSheets[0].insertRule(`
  .dot {
    position:absolute; 
    width:5px;
    height:5px;
    background-color:black;
  }
`)

= ネットワークを学ぶ

== Webにおけるネットワーク通信の基礎を理解する

=== URI

[LIST 13-1]
> url = new URL("https://amazon.com/s?k=javascript&ref=nb_sb_noss_2") 
URL {href: "https://amazon.com/s?k=javascript&ref=nb_sb_noss_2", …}
> url.protocol 
"https:"
> url.host 
"amazon.com"
> url.pathname 
"/s"
> url.search 
"?k=javascript&ref=nb_sb_noss_2"
> url.searchParams.get("k") 
"javascript"

[LIST 13-2]
> new URL("不正なURI") 
Uncaught TypeError: Failed to construct 'URL': Invalid URL
    at <anonymous>:1:1

[LIST 13-3]
> new URL("mailto:javascript@example.com") 
URL {href: "mailto:javascript@example.com", origin: "null", protocol: "mailto:", …}

[LIST 13-4]
> encodeURI("http://日本語.jp") 
"http://%E6%97%A5%E6%9C%AC%E8%AA%9E.jp"
> decodeURI("http://%E6%97%A5%E6%9C%AC%E8%AA%9E.jp") 
"http://日本語.jp"
> encodeURIComponent("http://日本語.jp") 
"http%3A%2F%2F%E6%97%A5%E6%9C%AC%E8%AA%9E.jp"
> decodeURIComponent("http%3A%2F%2F%E6%97%A5%E6%9C%AC%E8%AA%9E.jp") 
"http://日本語.jp"

=== HTTP

==== HTTPの概要を理解する

==== HTTPリクエストを送信する

[LIST 13-5]
curl -v telnet://〈ドメイン名（またはIPアドレス）〉:〈ポート番号〉

[LIST 13-6]
$ curl -v telnet://example.com:80 
* Rebuilt URL to: telnet://example.com:80/
*   Trying 93.184.216.34...
* TCP_NODELAY set
* Connected to example.com (93.184.216.34) port 80 (#0)

[LIST 13-7]
GET /index.html HTTP/1.1 
Host: example.com 
〈空行〉
# エンターキー 

[LIST 13-8]
[メソッド] [ドキュメントパス] [HTTPバージョン]
[ヘッダ名1]: [ヘッダ値1]
[ヘッダ名2]: [ヘッダ値2]
...
〈空行〉
# エンターキー 

==== HTTPレスポンスを確認する

[LIST 13-9]
HTTP/1.1 200 OK
Accept-Ranges: bytes
Age: 95126
Cache-Control: max-age=604800
Content-Type: text/html; charset=UTF-8
Date: Fri, 20 Mar 2020 14:30:16 GMT
Etag: "3147526947"
Expires: Fri, 27 Mar 2020 14:30:16 GMT
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Server: ECS (sjc/4E32)
Vary: Accept-Encoding
X-Cache: HIT
Content-Length: 1256

<!doctype html>
<html>
<head>
    <title>Example Domain</title>

    <meta charset="utf-8" />
    <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type="text/css">
    body {
        background-color: #f0f0f2;
        margin: 0;
        ... 

==== Chrome DevToolsでリクエスト／レスポンスを確認する

== Web API

=== REST

[LIST 13-10]
$ curl -v telnet://jsonplaceholder.typicode.com:80 
* Rebuilt URL to: telnet://jsonplaceholder.typicode.com:80/
*   Trying 104.28.13.240...
* TCP_NODELAY set
* Connected to jsonplaceholder.typicode.com (104.28.13.240) port 80 (#0)

[LIST 13-11]
GET /posts HTTP/1.1 
Host: jsonplaceholder.typicode.com 
〈空行〉
# エンターキー 

[LIST 13-12]
HTTP/1.1 200 OK
Date: Thu, 17 Oct 2019 15:18:21 GMT
Content-Type: application/json; charset=utf-8
...

[
  {
    "userId": 1,
    "id": 1,
    "title": "sunt aut facere repellat provident ...",
    "body": "quia et suscipit\nsuscipit recusandae ..."
  },
  {
    "userId": 1,
    "id": 2,
    "title": "qui est esse",
    "body": "est rerum tempore vitae\nsequi sint ..."
  },
  ...
]

[LIST 13-13]
POST /posts HTTP/1.1 
Host: jsonplaceholder.typicode.com 
Content-Type: application/json 
Content-Length: 62 

{"title":"Humpty Dumpty","body":"Humpty Dumpty sat on a wall"} 
〈空行〉
# エンターキー 

[LIST 13-14]
HTTP/1.1 201 Created
Date: Thu, 17 Oct 2019 15:25:16 GMT
Content-Type: application/json; charset=utf-8
...

{
  "title": "Humpty Dumpty",
  "body": "Humpty Dumpty sat on a wall",
  "id": 101
}

== リソースを取得する

[LIST 13-15]
> fetch("https://jsonplaceholder.typicode.com/posts") 
    .then(response => response.json()) 
    .then(json => console.log(json.length, json[0])) 
Promise {<pending>}
100
{userId: 1, id: 1, title: "sunt aut ...", body: "quia et ..."}
  userId: 1
  id: 1
  title: "sunt aut facere repellat ..."
  body: "quia et suscipit ..."
  __proto__: Object

=== レスポンスを確認する

[LIST 13-16]
> fetch("https://jsonplaceholder.typicode.com") 
    .then(response => response.text()) 
    .then(text => console.log(text)) 
Promise {<pending>}
<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, ..." />
<link rel="stylesheet" href="https://cdnjs.cloudfla..." />
<link rel="stylesheet" href="./style.css" />
<link rel="stylesheet" href="//cdnjs.cloudflare.com..." />
<script src="//cdnjs.cloudflare.com/ajax/libs/highl..."></script>
...

[LIST 13-17]
> fetch("https://jsonplaceholder.typicode.com") 
    .then(response => console.log(new Map(response.headers))) 
Promise {<pending>}
Map(3) {"cache-control" => "public, max-age=14400", ...}
  [[Entries]]
    0: {"cache-control" => "public, max-age=14400"}
    1: {"content-type" => "text/html; charset=UTF-8"}
    2: {"last-modified" => "Wed, 12 Feb 2020 04:26:06 GMT"}
    size: (...)
    __proto__: Map

== リソースを追加する

[LIST 13-18]
> fetch("https://jsonplaceholder.typicode.com/posts", { 
    method: "POST", 
    headers: {"Content-Type": "application/json"}, 
    body: '{"title":"Humpty Dumpty","body":"Humpty Dumpty sat on a wall"}' 
  }) 
  .then(response => response.json()) 
  .then(json => console.log(json)) 
Promise {<pending>}
{title: "Humpty Dumpty", body: "Humpty Dumpty sat on a wall", id: 101}

[LIST 13-19]
> let request = new Request("https://jsonplaceholder.typicode.com/posts", { 
    method: "POST", 
    headers: {"Content-Type": "application/json"}, 
    body: '{"title":"Humpty Dumpty","body":"Humpty Dumpty sat on a wall"}' 
  }) 
undefined
> fetch(request) 
      .then(response => response.json()) 
      .then(json => console.log(json)) 
Promise {<pending>}
{title: "Humpty Dumpty", body: "Humpty Dumpty sat on a wall", id: 101}

== リクエストの失敗を処理する

[LIST 13-20]
> fetch("https://jsonplaceholder.typicode.com/posts") 
    .then(response => console.log("ここには来ません")) 
    .catch(error => console.log(error)) 
Promise {<pending>}
GET https://jsonplaceholder.typicode.com/posts net::ERR_INTERNET_DISCONNECTED
(anonymous) @ VM77:1
TypeError: Failed to fetch

[LIST 13-21]
> fetch("https://jsonplaceholder.typicode.com/NotExist") 
    .then(response => console.log(response)) 
Promise {<pending>}
GET https://jsonplaceholder.typicode.com/NotExist 404 
(anonymous) @ VM5409:1
Response {type: "cors", url: "https://jsonplaceholder.typicode.com/NotExist", …}

[LIST 13-22]
> fetch("https://jsonplaceholder.typicode.com/NotExist").then(response => { 
    if (!response.ok) throw new Error(response.statusText) 
    // ...何らかの正常処理... 
  }).catch(error => console.log(error)) 
Promise {<pending>}
GET https://jsonplaceholder.typicode.com/NotExist 404
(anonymous) @ VM925:1
Error
    at <anonymous>:2:29

== ビーコンを送信する

[LIST 13-23]
> navigator.sendBeacon( 
    "https://jsonplaceholder.typicode.com/posts", 
    '{"title":"Humpty Dumpty","body":"Humpty Dumpty sat on a wall"}' 
  ) 
true

== HTTP以外のプロトコルを把握する

== まとめ

== 練習問題

= ストレージを学ぶ

== Cookie

=== Cookieの内容を確認する

[LIST 14-1]
> document.cookie 
"personalization_id="v1_sdIP9xVTLxfI2Ly5FQIQPA=="; guest_id=v1%3A15239347
8147851512; _ga=GA1.2.226164283.1523941847; lang=ja; ads_prefs="HBIRAAA="
; remember_checked_on=0; __utmc=43838368; __utmz=43838368.1525540793.1.1.
utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); syndication_guest_id=v1%3A
153248142555745911; twid=u%3D3382331; tfw_exp=0; __utma=43838368.22616428
3.1523941847.1570461066.1570891869.97; external_referer=padhuUp37zjYqXd9B
vj2xTeH6aRlQ9yl|0|8e8t2xd8A2w%3D; _gid=GA1.2.1992176916.1571764326; ct0=8
441cb09f5c13012567143baea9a7dd8; _gat=1"

[LIST 14-2]
> let cookieMap = () => new Map(document.cookie.split(/;\s*/).map(kv => { 
      const ms = kv.match(/([^=]+)=(.*)/) 
      return [ms[1], ms[2].replace(/(^"|"$)/g, "")] 
    })) 

[LIST 14-3]
> cookies = cookieMap() 
Map(15) {"personalization_id" => "v1_sdIP9xVTLxfI2Ly5FQIQPA==", …}
> cookies.get("lang") 
"ja"

[LIST 14-4]
> cookies.get("_twitter_sess") 
undefined

=== Cookieに値を設定する

[LIST 14-5]
> document.cookie = "power=E" 
"power=E"

[LIST 14-6]
> cookieMap().get("power") 
"E"

[LIST 14-7]
> document.cookie = "power=C" 
"power=C"
> cookieMap().get("power") 
"C"

[LIST 14-8]
> let doc = { 
    _cookie: new Map(), 
    get cookie() { 
      return [...this._cookie].map(kv => kv.join("=")).join(";") 
    }, 
    set cookie(val) { 
      this._cookie.set(...val.split("=")) 
    } 
  } 
undefined
> doc.cookie = "power=B" 
"power=B"
> doc.cookie = "speed=C" 
"speed=C"
> doc.cookie 
"power=B;speed=C"

=== Cookieに属性を設定する

[LIST 14-9]
> document.cookie = "power=B;max-age=10" 
"power=B;max-age=10"
> cookieMap().get("power") 
"B"
> cookieMap().get("power") 
undefined

[LIST 14-10]
> document.cookie = "power=B;max-age=1000" 
"power=B;max-age=1000"
> cookieMap().get("power") 
"B"
> document.cookie = "power=B;max-age=10" 
"power=B;max-age=10"
> cookieMap().get("power") 
"B"
> cookieMap().get("power") 
undefined

[LIST 14-11]
> document.cookie = "range=D;max-age=1000;path=/" 
"range=D;max-age=1000;path=/"

== Web Storage

=== Storageの値を読み取る

[LIST 14-12]
> localStorage.getItem("Session") 
"p08l87:1584968176078"

[LIST 14-13]
> localStorage.getItem("存在しないキー") 
null

=== Storageに値を設定する

[LIST 14-14]
> localStorage.setItem("power", "B") 
undefined
> localStorage.getItem("power") 
"B"

[LIST 14-15]
> localStorage.setItem("The Fool", {power:"B", speed:"C", range:"D"}) 
undefined
> localStorage.getItem("The Fool") 
"[object Object]"
> localStorage.setItem("The Fool",  
    JSON.stringify({power:"B", speed:"C", range:"D"})) 
undefined
> localStorage.getItem("The Fool") 
"{"power":"B","speed":"C","range":"D"}"
> JSON.parse(localStorage.getItem("The Fool")) 
{power: "B", speed: "C", range: "D"}

[LIST 14-16]
> while (true) { 
    try { 
      const longItem = localStorage.getItem("long item") 
      localStorage.setItem("long item", `${longItem}${longItem}`) 
    } catch (err) { 
      console.log(err) 
      break 
    } 
  } 
DOMException: Failed to execute 'setItem' on 'Storage': Setting the value 
of 'long item' exceeded the quota.
    at <anonymous>:3:18

=== Storageの値を削除する

[LIST 14-17]
> localStorage.setItem("power", "B") 
undefined
> localStorage.getItem("power") 
"B"
> localStorage.removeItem("power") 
undefined
> localStorage.getItem("power") 
null

[LIST 14-18]
> localStorage.setItem("power", null) 
undefined
> localStorage.getItem("power") 
"null"

[LIST 14-19]
> localStorage.setItem("power", "B") 
undefined
> localStorage.setItem("speed", "C") 
undefined
> localStorage.clear() 
undefined
> localStorage.getItem("power") 
null
> localStorage.getItem("speed") 
null

=== Storageのキーをすべて確認する

[LIST 14-20]
> for (let i = 0; i < localStorage.length; i++) { 
    console.log(localStorage.key(i)) 
  } 
long item
The Fool
...
power

=== Storageのイベントを処理する

[LIST 14-21]
> window.addEventListener("storage", evt => console.log(evt)) 
undefined
StorageEvent {isTrusted: true, key: "power", oldValue: "E", newValue: …}

== IndexedDB

=== 全体像を理解する

=== データベースに接続する

[LIST 14-22]
> indexedDB.open("jojodb", 1) 
IDBOpenDBRequest {onblocked: null, onupgradeneeded: null, source: null, …}

[LIST 14-23]
> let openRequest = indexedDB.open("jojodb", 1) 
  openRequest.addEventListener("success",  
    evt => console.log(`success: ${evt.target.result}`)) 
  openRequest.addEventListener("error",  
    evt => console.error(`error: ${evt.target.errorCode}`)) 
undefined
success: [object IDBDatabase]

=== オブジェクトストアを作成する

[LIST 14-24]
> let openRequest = indexedDB.open("jojodb", 2) 
  openRequest.addEventListener("upgradeneeded", evt => { 
    const db = evt.target.result 
    const standStore = db.createObjectStore("stands",  
      {keyPath:"id", autoIncrement:true}) 
    console.log(standStore) 
  }) 
undefined
IDBObjectStore {name: "stands", keyPath: "id", indexNames: …}

=== インデックスを定義する

[LIST 14-25]
> let db 
  let openRequest = indexedDB.open("jojodb", 1) 
  openRequest.addEventListener("upgradeneeded", evt => { 
    db = evt.target.result 
    const standStore = db.createObjectStore("stands",  
      {keyPath:"id", autoIncrement:true}) 
    standStore.createIndex("nameIndex", "name", {unique: true}) 
    standStore.createIndex("powerIndex", "power") 
  }) 

[LIST 14-26]
const standStore = [
  {data: "thehand"},
  {data: "echoes"},
  {data: "harvest"},
  {data: "ratt"}
]

[LIST 14-27]
const getHash = data => parseInt(data, 36)
const index = []
index[getHash("thehand")] = 0
index[getHash("echoes")]  = 1
index[getHash("harvest")] = 2
index[getHash("ratt")]    = 3

[LIST 14-28]
const pos = index[getHash("echoes")]
standStore[pos]

=== オブジェクトを追加する

[LIST 14-29]
> let transaction = db.transaction(["stands"], "readwrite") 
  transaction.addEventListener("complete",  
    evt => console.log("transaction complete")) 
  let standStore = transaction.objectStore("stands") 
  let addRequest = standStore.add( 
    {name:"The Fool", power:"B", speed:"C", range:"D"}) 
  addRequest.addEventListener("success",  
    evt => console.log(`add success (Key:${evt.target.result})`)) 
undefined
add success (Key:1)
transaction complete

[LIST 14-30]
let transaction = db.transaction(["stands"], "readwrite")
transaction.addEventListener("complete",
  evt => console.log("transaction complete"))

[LIST 14-31]
let standStore = transaction.objectStore("stands")
let addRequest = standStore.add(
  {name:"The Fool", power:"B", speed:"C", range:"D"})
addRequest.addEventListener("success", 
  evt => console.log("add success"))

[LIST 14-32]
add success (Key:1)
transaction complete

[LIST 14-33]
> let transaction = db.transaction("stands", "readwrite") 
  let standStore = transaction.objectStore("stands") 
  standStore.add({name:"Crazy Diamond", power:"A", speed:"A", range:"D"}) 
  standStore.add({name:"Echoes", power:"E", speed:"E", range:"B"}) 
  standStore.add({name:"The Hand", power:"B", speed:"B", range:"D"}) 
  standStore.add({name:"The World", power:"A", speed:"A", range:"C"}) 
  standStore.add({name:"Hierophant Green", power:"C", speed:"B", range:"A"}) 

=== キーを使用してオブジェクトを取得する

[LIST 14-34]
> let standStore = db.transaction("stands").objectStore("stands") 
  getRequest = standStore.get(1) 
  getRequest.addEventListener("success", 
    evt => console.log(evt.target.result)) 
undefined
{name: "The Fool", power: "B", speed: "C", range: "D", id: 1}

=== インデックスを使用してオブジェクトを取得する

[LIST 14-35]
> let transaction = db.transaction("stands") 
  let nameIndex = transaction.objectStore("stands").index("nameIndex") 
  nameIndex.get("Echoes").addEventListener("success", 
    evt => console.log(evt.target.result)) 
undefined
{name: "Echoes", power: "E", speed: "E", range: "B", id: 3}

[LIST 14-36]
> let standStore = db.transaction("stands").objectStore("stands") 
  let powerIndex = standStore.index("powerIndex") 
  powerIndex.getAll("B").addEventListener("success",  
    evt => console.log(evt.target.result)) 
undefined
(2) [{…}, {…}]
  0: {name: "The Fool", power: "B", speed: "C", range: "D", id: 1}
  1: {name: "The Hand", power: "B", speed: "B", range: "D", id: 4}
  length: 2
  __proto__: Array(0)

[LIST 14-37]
> let standStore = db.transaction("stands").objectStore("stands") 
  let powerIndex = standStore.index("powerIndex") 
  let range = IDBKeyRange.bound("A", "C") 
  powerIndex.getAll(range).addEventListener("success", 
    evt => console.log(evt.target.result)) 
undefined
(5) [{…}, {…}, {…}, {…}, {…}]
  0: {name: "Crazy Diamond", power: "A", speed: "A", range: "D", id: 2}
  1: {name: "The World", power: "A", speed: "A", range: "C", id: 5}
  2: {name: "The Fool", power: "B", speed: "C", range: "D", id: 1}
  3: {name: "The Hand", power: "B", speed: "B", range: "D", id: 4}
  4: {name: "Hierophant Green", power: "C", speed: "B", range: "A", id: 6}
  length: 5
  __proto__: Array(0)

[LIST 14-38]
> let standStore = db.transaction("stands").objectStore("stands") 
  let powerIndex = standStore.index("powerIndex") 
  let range = IDBKeyRange.bound("A", "C") 
  powerIndex.getAll(range, 3).addEventListener("success", 
    evt => console.log(evt.target.result)) 
undefined
(3) [{…}, {…}, {…}]
  0: {name: "Crazy Diamond", power: "A", speed: "A", range: "D", id: 2}
  1: {name: "The World", power: "A", speed: "A", range: "C", id: 5}
  2: {name: "The Fool", power: "B", speed: "C", range: "D", id: 1}
  length: 3
  __proto__: Array(0)

=== カーソルを使用してオブジェクトを取得する

[LIST 14-39]
> let standStore = db.transaction("stands").objectStore("stands") 
  standStore.openCursor().addEventListener("success", evt => { 
    const cursor = evt.target.result 
    if (cursor) { 
      console.log(cursor.value) 
      cursor.continue() 
    } else { 
      console.log("終了") 
    } 
  }) 
undefined
{name: "The Fool", power: "B", speed: "C", range: "D", id: 1}
{name: "Crazy Diamond", power: "A", speed: "A", range: "D", id: 2}
{name: "Echoes", power: "E", speed: "E", range: "B", id: 3}
{name: "The Hand", power: "B", speed: "B", range: "D", id: 4}
{name: "The World", power: "A", speed: "A", range: "C", id: 5}
{name: "Hierophant Green", power: "C", speed: "B", range: "A", id: 6}
終了

[LIST 14-40]
> let standStore = db.transaction("stands").objectStore("stands") 
  let range = IDBKeyRange.lowerBound(4) 
  standStore.openCursor(range).addEventListener("success", evt => { 
    const cursor = evt.target.result 
    if (cursor) { 
      console.log(cursor.value) 
      cursor.continue() 
    } 
  }) 
undefined
{name: "The Hand", power: "B", speed: "B", range: "D", id: 4}
{name: "The World", power: "A", speed: "A", range: "C", id: 5}
{name: "Hierophant Green", power: "C", speed: "B", range: "A", id: 6}

[LIST 14-41]
> let transaction = db.transaction("stands") 
  let powerIndex = transaction.objectStore("stands").index("powerIndex") 
  let range = IDBKeyRange.upperBound("C", true) 
  powerIndex.openCursor(range).addEventListener("success", evt => { 
    const cursor = evt.target.result 
    if (cursor) { 
      console.log(cursor.value) 
      cursor.continue() 
    } 
  }) 
undefined
{name: "Crazy Diamond", power: "A", speed: "A", range: "D", id: 2}
{name: "The World", power: "A", speed: "A", range: "C", id: 5}
{name: "The Fool", power: "B", speed: "C", range: "D", id: 1}
{name: "The Hand", power: "B", speed: "B", range: "D", id: 4}

=== オブジェクトを更新する

[LIST 14-42]
> let transaction = db.transaction("stands", "readwrite") 
  let standStore = transaction.objectStore("stands") 
  standStore.index("nameIndex").get("Echoes").addEventListener("success",  
    evt => { 
      const echoes = evt.target.result 
      echoes.power = "C" 
      echoes.speed = "D" 
      standStore.put(echoes) 
    }) 

[LIST 14-43]
> db.transaction("stands", "readwrite").objectStore("stands") 
    .put({id:3, name:"Echoes", power:"B", speed:"B", range:"C"}) 

=== オブジェクトを削除する

[LIST 14-44]
> db.transaction("stands", "readwrite").objectStore("stands").delete(5) 

== まとめ

== 練習問題

= マルチメディアを学ぶ

== DOM

=== 画像タグを利用する

[LIST 15-1]
> let img = new Image(250, 150) 
  img.src = "./JavaScript-logo.png" 
  document.body.prepend(img) 

[LIST 15-2]
> let img = new Image(250, 150) 
  img.addEventListener("load", evt => console.log( 
    img.width, img.height, img.naturalWidth, img.naturalHeight)) 
  img.src = "./JavaScript-logo.png" 
"./JavaScript-logo.png"
250 150 200 200

=== 動画タグを利用する

[LIST 15-3]
> video = document.getElementById("video") 
<video id="video" src="./Network-12716.mp4" controls width="400"></video>
> video.play() 
Promise {<pending>}
> video.pause() 
undefined

[LIST 15-4]
> video.currentTime 
5.038759
> video.currentTime = 10 
10

[LIST 15-5]
> video.paused 
true
> video.play() 
Promise {<pending>}
> video.paused 
false

[LIST 15-6]
> video.volume 
1
> video.volume = 0.5 
0.5

==== イベントを監視する

[LIST 15-7]
> video.addEventListener("play", evt => console.log("再生開始")) 
undefined
> video.addEventListener("pause", evt => console.log("一時停止")) 
undefined
> video.addEventListener("ended", evt => console.log("再生終了")) 
undefined
> video.play() 
Promise {<pending>}
再生開始
> video.pause() 
undefined
一時停止
> video.play() 
Promise {<pending>}
再生開始
一時停止
再生終了

=== 音声タグを利用する

[LIST 15-8]
> audio = document.getElementById("audio") 
<audio id="audio" src="./brook1.mp3" controls></audio>
> audio.play() 
Promise {<pending>}
> audio.pause() 
undefined
> audio.currentTime 
10.441253
> audio.volume 
1

[LIST 15-9]
> audio2 = new Audio("./fall_morning_river.mp3") 
<audio preload="auto" src="./fall_morning_river.mp3"></audio>
> audio2.play() 
Promise {<pending>}
> audio2.pause() 
undefined

== CSS

=== CSSを使用して画像を移動する

[LIST 15-10]
> img = document.getElementById("image") 
<img id="image" src="./JavaScript-logo.png" width="200">
> img.style.transform = "translate(100px, 50px)" 
"translate(100px, 50px)"

[LIST 15-11]
> img.style.transform = "translate(100px, 50px) rotate(45deg) " +  
    "scale(2, 0.5) skew(20deg, 0)" 
"translate(100px, 50px) rotate(45deg) scale(2, 0.5) skew(20deg, 0)"

[LIST 15-12]
> video = document.getElementById("video") 
<video id="video" src="./Network-12716.mp4" controls width="400"></video>
> video.style.transform = "rotate(-20deg) skew(0, 20deg)" 
"rotate(-20deg) skew(0, 20deg)"
> section = document.getElementsByTagName("section")[0] 
<section>…</section>
> section.style.transform = "translate(40px, 50px) rotate(110deg)" 
"translate(40px, 50px) rotate(110deg)"

=== CSSを使用して画像処理する

[LIST 15-13]
> img = document.getElementById("image") 
<img id="image" src="./JavaScript-logo.png" width="200">
> img.style.filter = "grayscale(50%)" 
"grayscale(50%)"
> img.style.filter = "blur(3px)" 
"blur(3px)"
> img.style.filter = "invert(100%)" 
"invert(100%)"
> img.style.filter = "grayscale(50%) blur(3px) invert(100%)" 
"grayscale(50%) blur(3px) invert(100%)"

=== CSSを使用してアニメーションする

[LIST 15-14]
> audio = document.getElementById("audio") 
<audio id="audio" src="./brook1.mp3" controls></audio>
> audio.style.filter = "invert(100%)" 
  audio.style.transform = "rotate(360deg)" 
"rotate(360deg)"

[LIST 15-15]
#audio {
  transition-property:transform, filter;
  transition-duration:2s;
  transition-timing-function:ease-in-out;
}

=== クラスを利用する

[LIST 15-16]
#audio.invert-rotate {
  filter: invert(100%);
  transform: rotate(360deg);
}

[LIST 15-17]
> audio = document.getElementById("audio") 
<audio id="audio" src="./brook1.mp3" controls></audio>
> audio.classList.toggle("invert-rotate") 
true
> audio.classList.toggle("invert-rotate") 
false

== SVG

[LIST 15-18]
> document.body.innerHTML = ` 
    <svg xmlns="http://www.w3.org/2000/svg"> 
      <rect x="10" y="10" width="160" height="100" fill="#09f" /> 
      <circle cx="80" cy="60" r="28" fill="#ff0" /> 
    </svg>` 

[LIST 15-19]
> let ns = "http://www.w3.org/2000/svg" 
  let svg = document.createElementNS(ns, "svg") 
  let rect = document.createElementNS(ns, "rect") 
  for (let [k, v] of Object.entries( 
    {x:10, y:10, width:160, height:100, fill:"#09f"})) { 
    rect.setAttribute(k, v) 
  } 
  let circle = document.createElementNS(ns, "circle") 
  for (let [k, v] of Object.entries( 
    {cx:80, cy:60, r:28, fill:"#ff0"})) { 
    circle.setAttribute(k, v) 
  } 
  svg.appendChild(rect) 
  svg.appendChild(circle) 
  document.body.prepend(svg) 

[LIST 15-20]
> circle.addEventListener("click", () => { 
    let color = `#${Math.floor(Math.random() * 0xffffff).toString(16)}` 
    circle.setAttribute("fill", color) 
  }) 

[LIST 15-21]
> document.body.innerHTML = ` 
    <svg viewBox="0 0 1200 450" xmlns="http://www.w3.org/2000/svg"> 
      <g fill="yellow" stroke="blue" stroke-width="5"> 
        <ellipse transform="translate(180 60)" 
          rx="170" ry="50" /> 
        <line x1="10" y1="200" x2="350" y2="250" /> 
        <polygon transform="translate(150 -50)" 
          points="350,75 379,161 469,161 397,215 423,301 
                  350,250 277,301 303,215 231,161 321,161" /> 
        <polyline transform="translate(-30, 50)" 
          points="50,375 150,375 150,325 250,325 250,375 
                  350,375 350,250 450,250 450,375" /> 
        <path transform="translate(-100 70)" 
          d="M600,350 l 50,-25 
             a25,25 -30 0,1 50,-25 l 50,-25 
             a25,50 -30 0,1 50,-25 l 50,-25 
             a25,75 -30 0,1 50,-25 l 50,-25 
             a25,100 -30 0,1 50,-25 l 50,-25" /> 
      </g> 
      <g font-size="30"> 
        <text x="130" y="70">ellipse</text> 
        <text x="150" y="200">line</text> 
        <text x="440" y="140">polygon</text> 
        <text x="120" y="350">polyline</text> 
        <text x="720" y="350">path</text> 
      </g> 
    </svg>` 

== Canvas

=== 図形を書く

[LIST 15-22]
> canvas = document.getElementById("canvas") 
<canvas id="canvas" width="200" height="200">

[LIST 15-23]
> ctx = canvas.getContext("2d") 
CanvasRenderingContext2D {canvas: canvas#canvas, globalAlpha: 1, …}

[LIST 15-24]
> ctx.beginPath()     // ❶
  ctx.moveTo(50, 50)  // ❷
  ctx.lineTo(50, 80)  // ❸
  ctx.lineTo(10, 80)  // ❹
  ctx.closePath()     // ❺
  ctx.stroke() 

[LIST 15-25]
> ctx.fill() 

[LIST 15-26]
> ctx.beginPath() 
  ctx.moveTo(55, 80) 
  ctx.arc(125, 80, 70, Math.PI, 0, true) 
  ctx.bezierCurveTo(170, 100, 120, -50, 55, 50) 
  ctx.closePath() 
  ctx.moveTo(105, 50) 
  ctx.ellipse(85, 50, 20, 15, 0, 0, 2 * Math.PI) 
  ctx.moveTo(90, 50) 
  ctx.arc(80, 50, 10, 0, 2 * Math.PI) 
  ctx.rect(10, 85, 40, 5) 
  ctx.fill() 

[LIST 15-27]
> ctx.clearRect(0, 0, 200, 200) 

=== 描画のスタイルを設定する

[LIST 15-28]
> ctx.fillStyle = "blue" 
"blue"
> ctx.strokeStyle = "red" 
"red"
> ctx.lineWidth = 3 
3
> ctx.fill() 
undefined
> ctx.stroke() 
undefined

=== 画像を表示する

[LIST 15-29]
> let img = document.getElementById("image") 
undefined
> let ctx = document.getElementById("canvas").getContext("2d") 
undefined
> for (let i = 0; i < 4; i++) ctx.drawImage(img, -50*i, -30*i) 
undefined

[LIST 15-30]
> ctx.clearRect(0, 0, 200, 200) 
undefined
> for (let i = 0; i < 4; i++) { 
    ctx.drawImage(img, 150-50*i, 100-30*i, 40, 70) 
  } 
undefined

[LIST 15-31]
> ctx.clearRect(0, 0, 200, 200) 
undefined
> ctx.drawImage(img, 100, 100, 50, 90, 10, 10, 180, 160) 
undefined

=== ピクセルを操作する

[LIST 15-32]
> let img = document.getElementById("image") 
  let ctx = document.getElementById("canvas").getContext("2d") 
  ctx.drawImage(img, 0, 0) 
  ctx.getImageData(0, 0, 200, 200) 
ImageData {data: Uint8ClampedArray(160000), width: 200, height: 200}

[LIST 15-33]
> let imageData = ctx.getImageData(0, 0, 200, 200) 
undefined
> let [r, g, b, a] = imageData.data 
undefined
> [r, g, b, a] 
(4) [242, 226, 140, 255]

[LIST 15-34]
> width = 200, height = 200, rgba = 4 
  row = height / 2 + 10 
  base = width * rgba * row + width / 2 * rgba 
  r = imageData.data[base + 0] 
  g = imageData.data[base + 1] 
  b = imageData.data[base + 2] 
  a = imageData.data[base + 3] 
255
> [r, g, b, a] 
(4) [50, 50, 48, 255]

[LIST 15-35]
> ctx.getImageData(100, 100, 1, 1).data 
Uint8ClampedArray(4) [50, 50, 48, 255]

[LIST 15-36]
> for (let y = 0; y < 200; y++) { 
    for (let w = 0, x = y; w < 20 && x < 200; w++, x++) { 
      imageData.data[y * 200 * 4 + x * 4] = 255 
      imageData.data[y * 200 * 4 + x * 4 + 1] = 0 
      imageData.data[y * 200 * 4 + x * 4 + 2] = 0 
      imageData.data[y * 200 * 4 + x * 4 + 3] = 255 
    } 
  } 
  ctx.putImageData(imageData, 0, 0) 

[LIST 15-37]
> const mx = 10, my = 10 
  for (let y = 0; y < 200; y += my) { 
    for (let x = 0; x < 200; x += mx) { 
      const r = imageData.data[y * 200 * 4 + x * 4] 
      const g = imageData.data[y * 200 * 4 + x * 4 + 1] 
      const b = imageData.data[y * 200 * 4 + x * 4 + 2] 
      const a = imageData.data[y * 200 * 4 + x * 4 + 3] 
      for (let dy = 0; dy < my; dy++) { 
        for (let dx = 0; dx < mx; dx++) { 
          imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4] = r 
          imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 1] = g 
          imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 2] = b 
          imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 3] = a 
        } 
      } 
    } 
  } 
  ctx.putImageData(imageData, 0, 0) 

=== オフスクリーンバッファを利用する

[LIST 15-38]
> let canvas = document.getElementById("canvas") 
  let ctx = canvas.getContext("bitmaprenderer") 

[LIST 15-39]
> let offscreen = new OffscreenCanvas(canvas.width, canvas.height) 
  offscreenCtx = offscreen.getContext("2d") 
  offscreenCtx.moveTo(105, 50) 
  offscreenCtx.ellipse(85, 50, 20, 15, 0, 0, 2 * Math.PI) 
  offscreenCtx.fill() 

[LIST 15-40]
> let bitmap = offscreen.transferToImageBitmap() 
  ctx.transferFromImageBitmap(bitmap) 

== WebGL

=== WebGLの利点

=== GPU

=== ポリゴン

=== シェーダー

[LIST 15-41]
void main(void) {
  gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  vTextureCoord = aTextureCoord;

  highp vec3 ambientLight = vec3(0.6, 0.6, 0.6);
  highp vec3 directionalLightColor = vec3(0.5, 0.5, 0.75);
  highp vec3 directionalVector = vec3(0.85, 0.8, 0.75);

  highp vec4 normal = uNormalMatrix * vec4(aVertexNormal, 1.0);

  highp float directional = max(dot(normal.xyz, directionalVector), 0.0);
  vLighting = ambientLight + (directionalLightColor * directional);
}

=== レンダリングパイプライン

=== ポリゴンを描画する

[LIST 15-42]
> canvas = document.getElementById("canvas") 
<canvas id="canvas" width="200" height="200">

[LIST 15-43]
> const gl = canvas.getContext("webgl") 

[LIST 15-44]
> let vertices = [ 
    -0.5, 0.5, 0, 
    -0.5, -0.5, 0, 
    0.5, -0.5, 0 
  ] 
  let vertexBuffer = gl.createBuffer() 
  gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) 
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), 
    gl.STATIC_DRAW) 
  gl.bindBuffer(gl.ARRAY_BUFFER, null) 

[LIST 15-45]
> let vertexCode = ` 
    attribute vec3 coordinates; 
    void main(void) { 
      gl_Position = vec4(coordinates, 1.); 
    } 
  ` 
  let vertexShader = gl.createShader(gl.VERTEX_SHADER) 
  gl.shaderSource(vertexShader, vertexCode) 
  gl.compileShader(vertexShader) 

[LIST 15-46]
> let fragmentCode = ` 
    void main(void) { 
      gl_FragColor = vec4(1., 1., 1., 1.); 
    } 
  ` 
  let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER) 
  gl.shaderSource(fragmentShader, fragmentCode) 
  gl.compileShader(fragmentShader) 

[LIST 15-47]
> let shaderProgram = gl.createProgram() 
  gl.attachShader(shaderProgram, vertexShader) 
  gl.attachShader(shaderProgram, fragmentShader) 
  gl.linkProgram(shaderProgram) 
  gl.useProgram(shaderProgram) 

[LIST 15-48]
> gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer) 
  let coordinates = gl.getAttribLocation(shaderProgram, "coordinates") 
  gl.vertexAttribPointer(coordinates, 3, gl.FLOAT, false, 0, 0) 
  gl.enableVertexAttribArray(coordinates) 

[LIST 15-49]
> gl.clearColor(0., 0., 0., 1.) 
  gl.enable(gl.DEPTH_TEST) 
  gl.clear(gl.COLOR_BUFFER_BIT) 
  gl.viewport(0, 0, canvas.width, canvas.height) 
  gl.drawArrays(gl.TRIANGLES, 0, 3) 

== Web Audio

=== 音の内部表現を理解する

=== 音を再生する

[LIST 15-50]
> let soundBuffer 
  let audioContext = new AudioContext() 
  fetch("./brook1.mp3").then(resp => { 
    return resp.arrayBuffer() 
  }).then(buffer => { 
    return audioContext.decodeAudioData(buffer) 
  }).then(buffer => { 
    soundBuffer = buffer 
    const source = audioContext.createBufferSource() 
    source.buffer = buffer 
    source.connect(audioContext.destination) 
    source.start(0) 
  }) 

=== 音にフィルタをかける

[LIST 15-51]
> let source = audioContext.createBufferSource() 
  source.buffer = soundBuffer 
  let filter = audioContext.createBiquadFilter() 
  filter.type = "lowpass" 
  filter.frequency.value = 500  
  source.connect(filter).connect(audioContext.destination) 
  source.start(0) 

=== 音を重ね合わせる

[LIST 15-52]
> let birdBuffer 
  fetch("./bulbul.mp3").then(resp => { 
    return resp.arrayBuffer() 
  }).then(buffer => { 
    return audioContext.decodeAudioData(buffer) 
  }).then(buffer => { 
    birdBuffer = buffer 
    const birdSource = audioContext.createBufferSource() 
    birdSource.buffer = buffer 
    birdSource.connect(audioContext.destination) 
    birdSource.start(audioContext.currentTime + 5, 0, 8) 

    const riverSource = audioContext.createBufferSource() 
    riverSource.buffer = soundBuffer 
    riverSource.connect(audioContext.destination) 
    riverSource.start(audioContext.currentTime) 
  }) 

=== 音を合成する

[LIST 15-53]
> let startPureToneNode = (ctx, startTime, baseFreq, factor) => { 
    const oscillatorNode = ctx.createOscillator() 
    oscillatorNode.type = "sine" 
    oscillatorNode.frequency.value = baseFreq * factor 

    const gainNode = ctx.createGain() 
    gainNode.gain.value = Math.floor(1 / factor) 

    oscillatorNode.connect(gainNode) 
    oscillatorNode.connect(audioContext.destination) 
    oscillatorNode.start(startTime) 
  } 

[LIST 15-54]
> let audioContext = new AudioContext() 
  let freq = 200 
  let startTime = audioContext.currentTime + 1 
  startPureToneNode(audioContext, startTime, freq, 1) 
  startPureToneNode(audioContext, startTime, freq, 3) 
  startPureToneNode(audioContext, startTime, freq, 5) 
  startPureToneNode(audioContext, startTime, freq, 7) 

=== 周波数を分析する

[LIST 15-55]
> let analyser = audioContext.createAnalyser() 
  analyser.fftSize = 256 
  let source = audioContext.createBufferSource() 
  source.buffer = birdBuffer 
  source.connect(analyser).connect(audioContext.destination) 

[LIST 15-56]
> let bufferLength = analyser.frequencyBinCount 
  let dataArray = new Uint8Array(bufferLength) 
  let height = 200 
  let ctx = document.getElementById("canvas").getContext("2d") 
  let imageData = ctx.getImageData(0, 0, bufferLength, height) 

[LIST 15-57]
> let count = 0 
  let draw = () => { 
    analyser.getByteFrequencyData(dataArray) 
    for (let i = 0; i < dataArray.length; i++) { 
      imageData.data[4*(128*count + i)] = dataArray[i] 
      imageData.data[4*(128*count + i) + 1] = dataArray[i] 
      imageData.data[4*(128*count + i) + 2] = dataArray[i] 
      imageData.data[4*(128*count + i) + 3] = 255 
    } 
    if (count < height) { 
      count++ 
      requestAnimationFrame(draw) 
    } else { 
      ctx.putImageData(imageData, 0, 0) 
    } 
  } 

[LIST 15-58]
> source.start(0, 0, 4) 
  draw() 

== マルチメディア系のアプリケーションでよく使用されるAPI

=== 定期的に処理を繰り返す

[LIST 15-59]
> let baseTime = performance.now() 
  let prevTime = baseTime 
  let animate = () => { 
    const now = performance.now() 
    console.log(now - prevTime) 
    prevTime = now 
    if (now - baseTime < 5000) window.requestAnimationFrame(animate) 
  } 
  animate() 
undefined
15.730000101029873
18.139999825507402
15.930000226944685
4114.749999716878

=== フルスクリーンでアプリケーションを利用する

[LIST 15-60]
> img = document.getElementById("image") 
<img id="image" src="./JavaScript-logo.png" width="200">
> img.requestFullscreen() 

[LIST 15-61]
> img.requestFullscreen().then(() => { 
    setTimeout(() => document.exitFullscreen(), 5000) 
  }) 

[LIST 15-62]
> img.addEventListener("fullscreenchange", () => { 
    if (document.fullscreenElement) { 
      setTimeout(() => document.exitFullscreen(), 5000) 
    } 
  }) 
undefined
> img.requestFullscreen() 
Promise {<pending>}

=== マウスポインタをロックする

[LIST 15-63]
> document.body.requestPointerLock() 

[LIST 15-64]
> document.exitPointerLock() 

==== マウスイベントを使用する

[LIST 15-65: 誤]
> // document.addEventListener("pointerlockchange", () => { 
  //   const mousemoveHandler = (evt) => { 
  //     console.log(`movement:${evt.movementX},${evt.movementY 
  //       } / client:${evt.clientX},${evt.clientY}`) 
  //   } 
  //   if (document.pointerLockElement) { 
  //     document.body.addEventListener("mousemove", mousemoveHandler) 
  //   } else { 
  //     document.body.removeEventListener("mousemove", mousemoveHandler) 
  //   } 
  // }, false) 
  // document.body.requestPointerLock() 

[LIST 15-65: 正]
> let mousemoveHandler = (evt) => { 
    console.log(`movement:${evt.movementX},${evt.movementY 
      } / client:${evt.clientX},${evt.clientY}`) 
  } 
> document.addEventListener("pointerlockchange", () => { 
    if (document.pointerLockElement) { 
      document.body.addEventListener("mousemove", mousemoveHandler) 
    } else { 
      document.body.removeEventListener("mousemove", mousemoveHandler) 
    } 
  }, false) 
  document.body.requestPointerLock() 
undefined
movement:0,7 / client:552,280
movement:-4,4 / client:552,280
movement:-13,5 / client:552,280

== まとめ

== 練習問題

[LIST 15-66]
> let img = new Image(250, 150) 
  img.src = "./JavaScript-logo.png" 
"./JavaScript-logo.png"
> img.addEventListener("load", evt => console.log( 
    img.width, img.height, img.naturalWidth, img.naturalHeight)) 
undefined

= センサーとデバイスを学ぶ

== Chrome DevToolsをAndroid端末に接続する

=== Android端末のUSBデバッグを有効にする

=== Chrome DevToolsをリモートデバイスに接続する

== センサー

=== デバイスの位置を取得する

[LIST 16-1]
> navigator.geolocation.getCurrentPosition( 
    position => console.log(position), err => console.log(err)) 
undefined

[LIST 16-2]
GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1586442365147}
  coords: GeolocationCoordinates
    latitude: 35.7738123
    longitude: 139.7976123
    altitude: null
    accuracy: 44
    altitudeAccuracy: null
    heading: null
    speed: null
    __proto__: GeolocationCoordinates
  timestamp: 1586442365147
  __proto__: GeolocationPosition

[LIST 16-3]
GeolocationPositionError {code: 1, message: "User denied Geolocation"}

[LIST 16-4]
> code = navigator.geolocation.watchPosition( 
    position => console.log(position), err => console.log(err)) 
1
GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1586444119535}
GeolocationPosition {coords: GeolocationCoordinates, timestamp: 1586444119535}

[LIST 16-5]
> navigator.geolocation.clearWatch(code) 
undefined

[LIST 16-6]
> let latitude = 35.68 
  let longitude = 139.75 
  let endpoint = "https://mreversegeocoder.gsi.go.jp/reverse-geocoder/" 
    + `LonLatToAddress?lat=${latitude}&lon=${longitude}` 
  fetch(endpoint).then(resp => resp.json()).then(json => console.log(json)) 
Promise {<pending>}
{results: {…}}
  results: {muniCd: "13101", lv01Nm: "千代田"}
  __proto__: Object

=== デバイスの向きを取得する

[LIST 16-7]
> window.addEventListener("deviceorientation", evt => 
    console.log(`alpha:${evt.alpha} beta:${evt.beta} gamma:${evt.gamma}`) 
  ) 
undefined
alpha:35.052049188834054 beta:48.36517576447388 gamma:9.080408394268883
alpha:34.26488229247634 beta:47.839188303977046 gamma:9.613504916480544
alpha:32.672785822882325 beta:46.77145927515688 gamma:10.65243504246575

[LIST 16-8]
let prev = {alpha:0, beta:0, gamma:0}
window.addEventListener("deviceorientation", evt => {
  const alpha = prev.alpha * 0.8 + evt.alpha * 0.2
  const beta = prev.beta * 0.8 + evt.beta * 0.2
  const gamma = prev.gamma * 0.8 + evt.gamma * 0.2
  prev = evt
  console.log(`alpha:${alpha} beta:${beta} gamma:${gamma}`)
})

==== デバイスの位置や向きの変化をテストする

=== 画面の向きの変化を取得する

[LIST 16-9]
> window.addEventListener("orientationchange", () => 
    console.log(`画面の角度: ${screen.orientation.angle}`)) 
undefined
画面の角度: 90
画面の角度: 0

==== 画面の向きの変化をテストする

=== センサーを利用する

[LIST 16-10]
const sensor = new SpecialSensor(オプション)
sensor.addEventListener("reading", () => {
  // sensorのプロパティを通じてセンセーの値を取得して利用
})
sensor.addEventListener("error", evt => {
  // evt.errorオブジェクトを使用してエラー処理
})
sensor.start()
sensor.stop()

==== デバイスの加速度を捕捉する

[LIST 16-11]
> let accelerometer = new Accelerometer({frequency: 1}) 
  accelerometer.addEventListener("reading", () => { 
    console.log(`X軸方向の加速度: ${accelerometer.x}`) 
    console.log(`Y軸方向の加速度: ${accelerometer.y}`) 
    console.log(`Z軸方向の加速度: ${accelerometer.z}`) 
  }) 
  accelerometer.start() 
undefined
X軸方向の加速度: 0.06703764945268631
Y軸方向の加速度: 0.5841852426528931
Z軸方向の加速度: 9.615114212036133
X軸方向の加速度: 0.038307227194309235
Y軸方向の加速度: 0.5937620401382446
Z軸方向の加速度: 9.634267807006836
> accelerometer.stop()
undefined

==== デバイスの角加速度を捕捉する

[LIST 16-12]
> let gyroscope = new Gyroscope({frequency: 1}) 
  gyroscope.addEventListener("reading", () => { 
    console.log(`X軸方向の角加速度: ${gyroscope.x}`) 
    console.log(`Y軸方向の角加速度: ${gyroscope.y}`) 
    console.log(`Z軸方向の角加速度: ${gyroscope.z}`) 
  }) 
  gyroscope.start() 
undefined
X軸方向の角加速度: 0
Y軸方向の角加速度: -0.0006108652451075613
Z軸方向の角加速度: 0.0006108652451075613
X軸方向の角加速度: -0.8857545852661133
Y軸方向の角加速度: -1.7739527225494385
Z軸方向の角加速度: 0.6688974499702454
> gyroscope.stop()
undefined

==== デバイスの動きを捕捉する

[LIST 16-13]
> let handler = evt => { 
    const acc = evt.acceleration 
    const acg = evt.accelerationIncludingGravity 
    const rot = evt.rotationRate 
    console.log(`加速度: (${acc.x}, ${acc.y}, ${acc.z})`) 
    console.log(`加速度+重力加速度: (${acg.x}, ${acg.y}, ${acg.z})`) 
    console.log(`角速度: (${rot.alpha}, ${rot.beta}, ${rot.gamma})`) 
  } 
  window.addEventListener("devicemotion", handler) 
undefined
加速度: (0.009576806798577309, 0, -0.19153612852096558)
加速度+重力加速度: (-0.13407529890537262, -0.12449848651885986, 9.672574996948242)
角速度: (0.10500000452271678, 0, -0.035000000395887826)

[LIST 16-14]
> window.removeEventListener("devicemotion", handler) 

== デバイス

=== デバイスを振動させる

[LIST 16-15]
> navigator.vibrate([ 
    1, 1, 3, 1, 3, 3,       // . _ _ 
    1, 1, 1, 1, 1, 1, 1, 3, // . . . .
    3, 1, 1, 1, 3, 1, 3, 3  // _ . _ _
  ].map(e => e*100)) 

=== Webカメラを利用する

[LIST 16-16]
> let video = document.getElementById("video") 
  navigator.mediaDevices.getUserMedia({video:true}).then(stream => { 
    video.srcObject = stream 
    video.onloadedmetadata = () => video.play() 
  }) 

[LIST 16-17]
> let canvas = document.getElementById("canvas") 
  let ctx = canvas.getContext("2d") 
  ctx.drawImage(video, 0, 0, 400, 255) 

[LIST 16-18]
> let mosaic = imageData => { 
    const mx = 10, my = 10 
    for (let y = 0; y < 200; y += my) { 
      for (let x = 0; x < 200; x += mx) { 
        const r = imageData.data[y * 200 * 4 + x * 4] 
        const g = imageData.data[y * 200 * 4 + x * 4 + 1] 
        const b = imageData.data[y * 200 * 4 + x * 4 + 2] 
        const a = imageData.data[y * 200 * 4 + x * 4 + 3] 
        for (let dy = 0; dy < my; dy++) { 
          for (let dx = 0; dx < mx; dx++) { 
            imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4] = r 
            imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 1] = g 
            imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 2] = b 
            imageData.data[(y+dy) * 200 * 4 + (x+dx) * 4 + 3] = a 
          } 
        } 
      } 
    } 
  } 

[LIST 16-19]
> let loopMosaic = (video, ctx) => { 
    ctx.drawImage(video, 0, 0, 400, 255) 
    let imageData = ctx.getImageData(0, 0, 200, 200) 
    mosaic(imageData) 
    ctx.putImageData(imageData, 0, 0) 
    requestAnimationFrame(() => loopMosaic(video, ctx)) 
  } 
  loopMosaic(video, ctx) 

== まとめ

== 練習問題

[LIST 16-20]
for (let propName of Object.getOwnPropertyNames(window)) {
  const prop = window[propName]
  if (Sensor.isPrototypeOf(prop)) {
    console.log(propName)
  }
}

= PWAを学ぶ

== Service Worker

=== Service Workerのライフサイクルを理解する

=== Service Workerの利用を開始する

[LIST 17-1]
<html>
  <head><meta charset="utf-8"></head>
  <body>
    <script>
      window.addEventListener("load", () => {
        navigator.serviceWorker.register("/sw.js").then(registration => {
          console.log("ServiceWorker登録成功")
          console.log(registration)
        }, err => {
          console.log("ServiceWorker登録失敗: ", err)
        })
      })
    </script>
  </body>
</html>

[LIST 17-2]
(index):9 ServiceWorker登録成功
(index):10 ServiceWorkerRegistration {
  scope: "http://localhost:8080/",
  updateViaCache: "imports",
  active: null, 
  installing: ServiceWorker,
  navigationPreload: NavigationPreloadManager, …}

[LIST 17-3]
self.addEventListener("install", event => {
  console.log(`install:${event}`)
})

self.addEventListener("activate", event => {
  console.log(`activate:${event}`)
})

[LIST 17-4]
sw.js:2 install:[object InstallEvent]

[LIST 17-5]
sw.js:6 activate:[object ExtendableEvent]

=== HTTPリクエストをプロキシする

[LIST 17-6]
self.addEventListener('fetch', event => {
  event.respondWith(new Promise((resolve, reject) => {
    const pathname = new URL(event.request.url).pathname
    if (pathname.startsWith("/proxy/")) {
      if (pathname.endsWith(".html")) {
        resolve(new Response("Proxy World!"))
      } else {
        resolve(Response.error())
      }
    } else {
      resolve(fetch(event.request))
    }
  }))
})

=== キャッシュを利用してオフラインで動作させる

[LIST 17-7]
./
├──index.html
├──sw1.js
└──v1/
　　　├──page1.html   @<ami>{インストール時にキャッシュする}
　　　└──page2.html   @<ami>{初回読み込み時にキャッシュする}

[LIST 17-8]
window.addEventListener("load", () => {
  navigator.serviceWorker.register("/sw1.js", {scope:"./v1/"}).then(
    registration => {
      console.log("ServiceWorker登録成功")
    }, err => {
      console.log("ServiceWorker登録失敗: ", err)
    })
})

[LIST 17-9]
self.addEventListener("install", event => {
  event.waitUntil(
    caches.open("v1").then(cache => {
      return cache.addAll([
        "/v1/page1.html"
      ])
    })
  )
})

[LIST 17-10]
self.addEventListener("fetch", event => {
  event.respondWith(caches.match(event.request))
})

[LIST 17-11]
self.addEventListener("fetch", event => {
  event.respondWith(caches.match(event.request).then(response => {
    return response || fetch(event.request)
  }))
})

[LIST 17-12]
self.addEventListener("fetch", event => {
  event.respondWith(caches.match(event.request).then(response => {
    return response || fetch(event.request).then(response => {
      return caches.open("v1").then(cache => {
        cache.put(event.request, response.clone())
        return response
      })
    })
  }))
})

=== プッシュ通知を利用する

==== プッシュ通知の仕組みを理解する

==== プッシュ通知を登録する

[LIST 17-13]
$ npm install web-push -g 
$ web-push generate-vapid-keys 

=======================================

Public Key:
ABcdeFG123ABcdeFG123ABcdeFG123ABcdeFG123ABcdeFG123ABcdeFG123ABcdeFG123AB...

Private Key:
456HiJ456HiJ456HiJ456HiJ456HiJ456HiJ456HiJ4

=======================================

[LIST 17-14]
const vapidKey = "ABcdeFG123ABcdeFG12...3ABcdeFG" // 作成した公開鍵
const convertedVapidKey = urlBase64ToUint8Array(vapidKey)

window.addEventListener("load", () => {
  navigator.serviceWorker.register("/sw.js").then(registration => {
    registration.pushManager.subscribe({
      userVisibleOnly: true,
      applicationServerKey: convertedVapidKey
    }).then(subscription => {
      console.log(subscription)
    })
  })
})

[LIST 17-15]
function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - base64String.length % 4) % 4);
  const base64 = (base64String + padding)
    .replace(/-/g, '+')
    .replace(/_/g, '/');

  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);

  for (let i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

[LIST 17-16]
PushSubscription {endpoint: "https://fcm.googleapis.com/fcm/se…}
  endpoint: "https://fcm.googleapis.com/fcm/send/aBcd_EF...Z9"
  expirationTime: null
  options: PushSubscriptionOptions {userVisibleOnly: true, …}
  __proto__: PushSubscription

==== プッシュ通知を受け取る

[LIST 17-17]
self.addEventListener("push", event => {
  console.log(`プッシュ通知: ${event.data.text()}`)
})

[LIST 17-18]
sw.js:2 Test push message from DevTools.

==== 通知ダイアログを表示する

[LIST 17-19]
self.addEventListener("push", event => {
  const data = event.data.json()
  event.waitUntil(
    self.registration.showNotification(data.title, {body:data.body}))
})

[LIST 17-20]
{"title":"とうおるるるる", "body":"…………もしもし、はいドッピオです"}

== Web App Manifest

=== アプリに関する情報を提供する

[LIST 17-21]
<link rel="manifest" href="manifest.webmanifest">

[LIST 17-22]
{
  "name": "サンプルアプリ名",
  "description": "どのようなアプリであるかの説明",
  "display": "fullscreen",
  "icons": [{
    "src": "images/icon.png",
    "sizes": "192x192"
  }],
  "start_url": "/"
}

=== アプリをホーム画面に追加する

== ネイティブアプリを超える

=== Web Share API

[LIST 17-23]
> navigator.share({ 
    url: "https://www.technohippy.dev/handsonjs/", 
    title: "ハンズオンJavaScriptサンプルコード", 
    text: "サポートサイト" 
  }) 

=== Payment Request API

[LIST 17-24]
Object
  details: 
    billingAddress: {addressLine: Array(1), city: "Tokyo", …}
    cardNumber: "3333222211110000"
    cardSecurityCode: "321"
    cardholderName: "YASUSHI ANDO"
    expiryMonth: "11"
    expiryYear: "2222"
    __proto__: Object
  methodName: "basic-card"
  payerEmail: null
  payerName: null
  payerPhone: null
  requestId: "33333333-2222-1111-0000-aaaaaaaaaaaa"
  shippingAddress: null
  shippingOption: null
  __proto__: Object

[LIST 17-25]
let supportedInstruments = [{
  supportedMethods: ["basic-card"],
  data: {supportedNetworks: ["visa", "mastercard"]}
}]
let details = {
  displayItems: [
    {label: "かけそば", amount: {currency: "JPY", value: "150"}}
  ],
  total: {label: "合計", amount: {currency: "JPY", value : "150"}}
}
let request = new PaymentRequest(supportedInstruments, details)
request.show().then(result => {
  console.log(result.toJSON())
  // result.toJSON()をサーバに送信して決済を実行する
  result.complete("success")
})

== まとめ

== 練習問題

= セキュリティを学ぶ

== サンドボックス

=== 同一オリジンポリシー

==== CORS

[LIST 18-1]
$ curl -v telnet://jsonplaceholder.typicode.com:80 
* Rebuilt URL to: telnet://jsonplaceholder.typicode.com:80/
*   Trying 104.28.12.240...
* TCP_NODELAY set
* Connected to jsonplaceholder.typicode.com (104.28.12.240) port 80 (#0)

[LIST 18-2]
GET /posts HTTP/1.1 
Host: jsonplaceholder.typicode.com 
Origin: http://localhost:8080 
〈空行〉
# エンターキー 

[LIST 18-3]
HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Transfer-Encoding: chunked
Connection: keep-alive
Set-Cookie: __cfduid=dee02...
X-Powered-By: Express
Access-Control-Allow-Origin: http://localhost:8080
...

== 代表的な攻撃

=== クロスサイトスクリプティング

[LIST 18-4]
<script>alert(document.cookie)</script>

=== クロスサイトリクエストフォージェリ

[LIST 18-5]
<!doctype html>
<html>
  <body>
    <form id="reset" action="http://target.com/resetpassword" method="post">
      <input name="new_password" value="NEWPASSWORD">
    </form>
    <script>
      document.getElementById("reset").submit()
    </script>
  </body>
</html>

=== セキュリティ機能

== ブラウザに保存された認証情報を利用する

=== パスワード認証を自動的に行う

[LIST 18-6]
> navigator.credentials.get({ 
    password: true 
  }).then(cred => console.log(cred)) 
Promise {<pending>}
PasswordCredential {iconURL: "", name: "", password: "abcabc",
id: "andoyasushi@example.com", type: "password"}

[LIST 18-7]
> navigator.credentials.get({ 
    password: true 
  }).then(cred => console.log(cred)) 
Promise {<pending>}

[LIST 18-8]
PasswordCredential {iconURL: "", name: "", password: "abcabc",
id: "andoyasushi@example.com", type: "password"}

=== IDプロバイダを使用した認証を自動的に行う

[LIST 18-9]
> navigator.credentials.get({ 
    federated: { 
      providers: [ 
        "https://accounts.google.com" 
      ] 
    } 
  }).then(cred => console.log(cred)) 
Promise {<pending>}
FederatedCredential {iconURL: "https://lh3.googleusercon...", 
name: "Yasushi Ando", …}

=== ログインに使用するアカウントを選択する

[LIST 18-10]
> navigator.credentials.get({ 
    password: true, 
    federated: { 
      providers: [ 
        "https://accounts.google.com" 
      ] 
    } 
  }).then(cred => console.log(cred)) 

== 公開鍵暗号を使用してログインする

=== 公開鍵暗号方式を理解する

=== WebAuthnの処理の流れを理解する

==== 公開鍵登録の流れを理解する

==== 認証の流れを理解する

=== WebAuthnの認証情報を生成する

[LIST 18-11]
> let credRawId 
  credParams = { 
    publicKey: { 
      rp: { 
        name: "RP Name" 
      }, 
      user: { 
        id: new Uint8Array(), 
        name: "user@example.com", 
        displayName: "User Name" 
      }, 
      pubKeyCredParams: [{ 
        type: "public-key", 
        alg: -7 
      }], 
      challenge: new ArrayBuffer() 
    } 
  } 
  navigator.credentials.create(credParams).then(cred => { 
    credRawId = cred.rawId 
    let response = cred.response 
    // このresponseをサーバに送り返す 
    console.log(cred) 
  }) 

[LIST 18-12]
PublicKeyCredential {rawId: ArrayBuffer(59), response: ...}

=== WebAuthnの認証情報を取得する

[LIST 18-13]
> credParams = { 
    publicKey: { 
      allowCredentials: [{ 
        id: credRawId, 
        type: "public-key" 
      }], 
      challenge: new ArrayBuffer() 
    } 
  } 
  navigator.credentials.get(credParams).then(cred => console.log(cred)) 

[LIST 18-14]
PublicKeyCredential {rawId: ArrayBuffer(59), response: AuthenticatorAttestationResponse, ...}

== まとめ

== 練習問題

= パフォーマンスを学ぶ

== パフォーマンスを定義する

== パフォーマンスを評価する

=== Chrome DevToolsを使用する

==== ［Lighthouse］タブを使用する

==== ［Performance］タブを使用する

=== 独自に評価する

==== 詳細な時間を測定する

[LIST 19-1]
> Date.now() 
1578372273352

[LIST 19-2]
> performance.now() 
40897.984999988694

[LIST 19-3]
> performance.timeOrigin 
1578394417894.628

[LIST 19-4]
> function longMethod() { 
    let sum = 0; 
    for (let i = 0; i < 100000000; i++) { 
      sum += Math.random(); 
    } 
    return sum; 
  } 
undefined
> console.time("longMethod") 
  longMethod() 
  console.timeEnd("longMethod") 
longMethod: 948.091064453125ms
undefined

==== リソース読み込みのパフォーマンスを確認する

[LIST 19-5]
> let name = "https://www.oreilly.co.jp/images/ml-header-home-blinking.gif" 
  performance.getEntriesByName(name) 
[PerformanceResourceTiming]
  0: PerformanceResourceTiming
    initiatorType: "img"
    nextHopProtocol: "h2"
    workerStart: 0
    redirectStart: 0
    redirectEnd: 0
    fetchStart: 119.62999997194856
    domainLookupStart: 119.62999997194856
    domainLookupEnd: 119.62999997194856
    connectStart: 119.62999997194856
    connectEnd: 119.62999997194856
    secureConnectionStart: 119.62999997194856
    requestStart: 126.20499997865409
    responseStart: 169.34999998193234
    responseEnd: 170.0950000085868
    transferSize: 15167
    encodedBodySize: 15004
    decodedBodySize: 15004
    serverTiming: []
    name: "https://www.oreilly.co.jp/images/ml-header-home-blinking.gif"
    entryType: "resource"
    startTime: 119.62999997194856
    duration: 50.46500003663823
    __proto__: PerformanceResourceTiming
  length: 1
  __proto__: Array(0)

[LIST 19-6]
> performance.getEntriesByType("resource").map(p => p.name) 
(35) ["https://www.oreilly.co.jp/css/main.css", "https://www.oreill...]
  0: "https://www.oreilly.co.jp/css/main.css"
  1: "https://www.oreilly.co.jp/images/ml-header-home-blinking.gif"
  2: "https://www.oreilly.co.jp/images/basketicon.gif"
  3: "https://www.oreilly.co.jp/images/default_banner.png"
  4: "https://www.oreilly.co.jp/books/images/picture_small978-4-87311-885-7.gif"
  5: "https://www.oreilly.co.jp/books/images/picture_small978-4-87311-890-1.gif"
  ...
  length: 35
  __proto__: Array(0)

==== Webサイト表示のパフォーマンスを確認する

[LIST 19-7]
> performance.getEntriesByType("navigation")[0] 
PerformanceNavigationTiming {unloadEventStart: 480.82000005...}
  unloadEventStart: 480.82000005524606
  unloadEventEnd: 480.82000005524606
  domInteractive: 3366.000000038184
  domContentLoadedEventStart: 3366.0150000359863
  domContentLoadedEventEnd: 3366.8600000673905
  domComplete: 4117.605000035837
  loadEventStart: 4117.620000033639
  loadEventEnd: 4117.629999993369
  type: "reload"
  redirectCount: 0
  initiatorType: "navigation"
  nextHopProtocol: "h2"
  workerStart: 0
  redirectStart: 0
  redirectEnd: 0
  fetchStart: 2.3250000085681677
  domainLookupStart: 3.810000023804605
  domainLookupEnd: 45.72499997448176
  connectStart: 45.72499997448176
  connectEnd: 413.5500000556931
  secureConnectionStart: 75.52499999292195
  requestStart: 413.6949999956414
  responseStart: 451.4750000089407
  responseEnd: 452.2700000088662
  transferSize: 6547
  encodedBodySize: 6416
  decodedBodySize: 22581
  serverTiming: []
  name: "https://www.oreilly.co.jp/index.shtml"
  entryType: "navigation"
  startTime: 0
  duration: 4117.629999993369
  __proto__: PerformanceNavigationTiming

==== 独自のパフォーマンスを測定する

[LIST 19-8]
> performance.mark("male") 
  performance.mark("female") 
  performance.mark("male") 
  performance.mark("male") 
  performance.mark("female") 
  performance.mark("male") 
  performance.mark("female") 

[LIST 19-9]
> performance.getEntriesByName("female")[0] 
PerformanceMark {detail: null, name: "female", entryType: ...}
  detail: null
  name: "female"
  entryType: "mark"
  startTime: 36584454.20499996
  duration: 0
  __proto__: PerformanceMark
> performance.getEntriesByType("mark").map(e => e.name)
(7) ["male", "female", "male", "male", "female", "male", "female"]

[LIST 19-10]
> performance.mark("start") 
  setTimeout(() => { 
    performance.mark("middle") 
    setTimeout(() => { 
      performance.mark("end") 
      performance.measure("start to middle", "start", "middle") 
      performance.measure("start to end", "start", "end") 
      console.log(performance.getEntriesByType("measure")) 
    }, 1000) 
  }, 2000) 
6
(2) [PerformanceMeasure, PerformanceMeasure]
  0: PerformanceMeasure
    detail: null
    name: "start to middle"
    entryType: "measure"
    startTime: 259965.36999987438
    duration: 2004.1000000201166
    __proto__: PerformanceMeasure
  1: PerformanceMeasure
    detail: null
    name: "start to end"
    entryType: "measure"
    startTime: 259965.36999987438
    duration: 3008.335000136867
    __proto__: PerformanceMeasure
  length: 2
  __proto__: Array(0)

[LIST 19-11]
> performance.clearMarks() 
  performance.clearMeasures() 

==== パフォーマンスエントリの追加を監視する

[LIST 19-12]
> let observer = new PerformanceObserver(entries => 
    console.log(entries.getEntries().map(e => e.name))) 
  observer.observe({type:"mark"}) 

[LIST 19-13]
> performance.mark("オラ") 
PerformanceMark {detail: null, name: "オラ", entryType: "mark", ...}
["オラ"]
> performance.mark("オラオラ") 
PerformanceMark {detail: null, name: "オラオラ", entryType: "mark", ...}
["オラオラ"]

== パフォーマンスを改善する

=== Web Worker

==== ワーカーを開始する

[LIST 19-14]
console.log("worker1実行中")
while (true) {}

[LIST 19-15]
> worker1 = new Worker("js/worker1.js") 
Worker {onmessage: null, onerror: null}
worker1.js:1 worker1実行中

[LIST 19-16]
> worker1.terminate() 

==== ワーカーとメッセージをやりとりする

[LIST 19-17]
self.addEventListener("message", event => {
  const name = event.data
  if (typeof name !== "string") throw "名前が文字列ではありません"
  self.postMessage(`Hello, ${name}`)
})

[LIST 19-18]
> worker2 = new Worker("js/worker2.js") 
Worker {onmessage: null, onerror: null}
> worker2.addEventListener("message",  
    event => console.log(`受信「${event.data}」`)) 
undefined
> worker2.postMessage("World") 
undefined
受信「Hello, World」

[LIST 19-19]
> worker2.postMessage("my friend") 
undefined
受信「Hello, my friend」

==== ワーカーで発生した例外を捕捉する

[LIST 19-20]
> try { 
    worker2.postMessage(63194) 
  } catch(err) { 
    console.error(`例外を捕捉: ${err}`) 
  } 
undefined
worker2.js:3 Uncaught 名前が文字列ではありません
(anonymous) @ worker2.js:3

[LIST 19-21]
> worker2.addEventListener("error", event => { 
    console.error(`例外を捕捉: ${event.message}`) 
  }) 
undefined
> worker2.postMessage(63194) 
undefined
例外を捕捉: Uncaught 名前が文字列ではありません
  (anonymous) @ VM540:2
  error (async)
  (anonymous) @ VM540:1
worker2.js:3 Uncaught 名前が文字列ではありません
  (anonymous) @ worker2.js:3

==== ワーカーとやりとりするデータについて理解する

[LIST 19-22]
let messageData
self.addEventListener("message", event => messageData = event.data)

[LIST 19-23]
> worker3 = new Worker("js/worker3.js") 
Worker {onmessage: null, onerror: null}
> worker3.postMessage(function() {}) 
Uncaught DOMException: Failed to execute 'postMessage' on 'Worker': 
function() {} could not be cloned.
    at <anonymous>:1:9
(anonymous) @ VM609:1
> worker3.postMessage(document.body) 
Uncaught DOMException: Failed to execute 'postMessage' on 'Worker': 
HTMLBodyElement object could not be cloned.
    at <anonymous>:1:9
(anonymous) @ VM604:1

[LIST 19-24]
> const surface = {power:"B", speed:"B", range:"C"} 
  worker3.postMessage(surface) 

[LIST 19-25]
> messageData 
{power: "B", speed: "B", range: "C"}
> messageData["power"] = "A" 
"A"
> messageData 
{power: "A", speed: "B", range: "C"}

[LIST 19-26]
> surface 
{power: "B", speed: "B", range: "C"}

[LIST 19-27]
> surface["speed"] = "A" 
"A"
> surface 
{power: "B", speed: "A", range: "C"}

[LIST 19-28]
> messageData 
{power: "A", speed: "B", range: "C"}

[LIST 19-29]
> gf = new Uint32Array([81194, 22194, 63194]) 
Uint32Array(3) [81194, 22194, 63194]
> worker3.postMessage({member: gf.buffer}, [gf.buffer]) 
undefined
> gf 
Uint32Array []

[LIST 19-30]
> new Uint32Array(messageData.member) 
Uint32Array(3) [81194, 22194, 63194]

==== ワーカーに別のスクリプトファイルを取り込む

[LIST 19-31]
importScripts("https://cdnjs.cloudflare.com/ajax/libs/mathjs/6.6.2/math.js")
self.addEventListener("message", event => {
  postMessage(math.evaluate(event.data))
})

[LIST 19-32]
> worker4 = new Worker("js/worker4.js") 
Worker {onmessage: null, onerror: null}
> worker4.addEventListener("message", event => console.log(event.data)) 
undefined
> worker4.postMessage("9 / 3 + 2i") 
undefined
{re: 3, im: 2}

==== ワーカーでcanvasに描画する

[LIST 19-33]
let canvas
self.addEventListener("message", event => {
  if ("canvas" in event.data) canvas = event.data.canvas

  const ctx = canvas.getContext("2d")
  ctx.fillStyle = event.data.color
  ctx.beginPath()
  ctx.moveTo(50, 50)
  // ...省略...
  ctx.rect(10, 85, 40, 5)
  ctx.fill()
})

[LIST 19-34]
> let canvas = document.getElementById("canvas") 
  let offscreen = canvas.transferControlToOffscreen() 
  let worker5 = new Worker("js/worker5.js") 
  worker5.postMessage({canvas:offscreen, color:"blue"}, [offscreen]) 

==== ワーカーを共有する

[LIST 19-35]
> worker3 = new Worker("js/worker3.js") 
Worker {onmessage: null, onerror: null}

[LIST 19-36]
> worker3.postMessage("tab1") 
undefined

[LIST 19-37]
> messageData 
"tab1"

> messageData 
undefined

[LIST 19-38]
let messageData = "初期値"

self.addEventListener("connect", event => {
  let port = event.ports[0]
  port.addEventListener("message", event => {
    let prevData = messageData
    messageData = event.data
    port.postMessage(prevData)
  })
  port.start()
})

[LIST 19-39]
> let shared6 = new SharedWorker("js/worker6.js") 
  shared6.port.addEventListener("message", 
    event => console.log(event.data)) 
  shared6.port.start() 
  shared6.port.postMessage("タブ1") 
undefined
初期値

[LIST 19-40]
> let shared6 = new SharedWorker("js/worker6.js") 
  shared6.port.addEventListener("message", 
    event => console.log(event.data)) 
  shared6.port.start() 
  shared6.port.postMessage("タブ2") 
undefined
タブ1

[LIST 19-41]
> messageData 
"タブ2"

=== WebAssembly

[LIST 19-42]
(module
  ;; JSから受け取る関数
  (import "console" "log" (func $log (param i32)))

  ;; JSと共有する記憶領域
  (import "js" "mem" (memory 1))

  ;; JSから利用できるadd関数定義
  (func (export "add") (param $v1 i32) (param $v2 i32)

    ;; 変数宣言
    (local $result i32)

    ;; 引数を合計した結果を$resultに保存
    (set_local $result (i32.add (get_local $v1) (get_local $v2)))

    ;; 結果を共有領域に保存
    (i32.store (i32.const 0) (get_local $result))

    ;; 結果を$log関数で表示
    (call $log (get_local $result))
  )
)

==== JavaScriptからwasmで記述された関数を呼び出す

[LIST 19-43]
> let memory = new WebAssembly.Memory({initial:1}) 
  let opts = { 
    js: { mem: memory }, 
    console: { log: v => console.log(`インポートした関数で表示: ${v}`) } 
  } 
  WebAssembly.instantiateStreaming(fetch("wasm/add.wasm"), opts).then( 
    obj => { 
      obj.instance.exports.add(40, 2) 
      console.log(`メモリから取得: ${new Int32Array(memory.buffer)[0]}`) 
    } 
  ) 
Promise {<pending>}
インポートした関数で表示: 42
メモリから取得: 42

== まとめ

== 練習問題

= 学び続けるために

== ECMAScript

=== 標準化プロセス

== Web API

=== 標準化プロセス

== 参考サイト

=== TC39

=== JavaScriptエンジン

=== Web技術全般

== まとめ

== 練習問題

= JavaScriptのオブジェクト指向

== プロトタイプチェーン

[LIST 21-1]
> let tusk1 = { 
    cry: "Chumimin", 

    act1() { 
      console.log(this.cry) 
    } 
  } 
undefined
> let tusk2 = { 
    __proto__: tusk1, 

    act2() { 
      super.act1() 
      console.log("Tail") 
    } 
  } 
undefined
> tusk2.cry 
"Chumimin"
> tusk2.act1() 
Chumimin
undefined
> tusk2.act2() 
Chumimin
Tail
undefined

== コンストラクタ

[LIST 21-2]
> function Func() { 
    this.prop = "プロパティ" 
    // this.method = () => `メソッド:${this.prop}` 
  } 
  Func.prototype = { 
    method: function() { 
      return `メソッド:${this.prop}` 
    } 
  } 

[LIST 21-3]
> let obj = new Func() 
undefined
> obj.prop 
"プロパティ"
> obj.method() 
"メソッド:プロパティ"
> Object.getPrototypeOf(obj) 
{method: ƒ}
> Object.getPrototypeOf(obj) === Func.prototype 
true

[LIST 21-4]
> function myNew(func) { 
    const obj = {} 
    func.apply(obj) 
    Object.setPrototypeOf(obj, func.prototype) 
    return obj 
  } 

[LIST 21-5]
> let obj2 = myNew(Func) 
undefined
> obj2.prop 
"プロパティ"
> obj2.method() 
"メソッド:プロパティ"
> Object.getPrototypeOf(obj2) 
{method: ƒ}
> Object.getPrototypeOf(obj2) === Func.prototype 
true

== 継承

[LIST 21-6]
> function ChildFunc() { 
    Func.call(this) 
    this.childProp = "子プロパティ" 
  } 
  ChildFunc.prototype = { 
    childMethod: function() { 
      return "子メソッド" 
    } 
  } 
  Object.setPrototypeOf(ChildFunc.prototype, Func.prototype) 
  ChildFunc.prototype.constructor = ChildFunc 

[LIST 21-7]
ChildFunc.prototype = Object.create(Func.prototype, {
  childMethod: {
    value: function() {
      return "子メソッド"
    }
  }
})

[LIST 21-8]
> let child = new ChildFunc() 
undefined
> child.childProp 
"子プロパティ"
> child.childMethod() 
"子メソッド"
> child.prop 
"プロパティ"
> child.method() 
"メソッド:プロパティ"

== クラス

[LIST 21-9]
class ParentClass {
  constructor() {
    this.parentProp = "親プロパティ"
  }

  parentMethod() {
    return "親メソッド"
  }
}

class ChildClass extends ParentClass {
  constructor() {
    super()
    this.childProp = "子プロパティ"
  }

  childMethod() {
    return "子メソッド"
  }
}

[LIST 21-10]
> typeof ChildClass 
"function"

[LIST 21-11]
> ChildClass() 
Uncaught TypeError: Class constructor ChildClass cannot be invoked without 'new'
    at <anonymous>:1:1
(anonymous) @ VM5616:1

[LIST 21-12]
> ChildClass.prototype 
ParentClass {constructor: ƒ, childMethod: ƒ}
  constructor: class ChildClass
  childMethod: ƒ childMethod()
  __proto__: 
    constructor: class ParentClass
    parentMethod: ƒ parentMethod()
    __proto__: Object

[LIST 21-13]
> let c = new ChildClass() 
undefined
> Object.getPrototypeOf(c) === ChildClass.prototype 
true
> c.constructor === ChildClass 
true

= ローカル環境でサポートサイトを動作させる

== サポートサイトのコードを取得する

== Webサーバを起動する

[LIST 22-1]
> npm install -g http-server

[LIST 22-2]
$ http-server
Starting up http-server, serving ./
Available on:
  http://127.0.0.1:8080
  http://192.168.11.5:8080
Hit CTRL-C to stop the server

= 練習問題の解答

== 1章 学び始めるまえに

[LIST 23-1]
玄関を出る
右に曲がる
字下げしている部分を繰り返す
　もし右にパン屋があれば、字下げしている部分を実行
　　左を向いて止まる
　　繰り返しを止める
　そうでなければ、字下げしている部分を実行
　　直進する
字下げしている部分を繰り返す
　歩行者用信号が青なら、字下げしている部分を実行
　　横断歩道を渡る
　　繰り返しを止める
　そうでなければ、字下げしている部分を実行
　　何もしない
左折する
字下げしている部分を繰り返す
　もし左に小学校があれば、字下げしている部分を実行
　　終わる
　そうでなければ、字下げしている部分を実行
　　直進する

[LIST 23-2]
> let ca = new CA1({ 
    rule:30,  
    states:[ 
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 
      1, 
      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 
    ] 
  }) 
  for (let i = 0; i <= 20; i++) { 
    addResult(ca) 
    ca.next() 
  } 

== 2章 データを学ぶ

[LIST 23-3]
海にいる & 糸で釣る & !魚 & 空を飛ぶ & !鳥 & (赤い | 白い)

[LIST 23-4]
> 1 + 2 + 3 + "ダー" 
"6ダー"
> "加藤" + 1 + 2 + 3 
"加藤123"

[LIST 23-5]
> let days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
undefined
> days[5] 
30

[LIST 23-6]
> let ko1 = {id: 1, name: "Echoes", parameters: [ 
    {power: "E", speed: "E", range: "B"}, // ACT1 
    {power: "C", speed: "D", range: "B"}, // ACT2 
    {power: "B", speed: "B", range: "C"}, // ACT3 
  ]} 
undefined
> let {name, parameters:[{speed:speed1}, , {speed:speed3}]} = ko1 
undefined
> [name, speed1, speed3] 
(4) ["Echoes", "E", "B"]

[LIST 23-7]
> 600 - 100 * 2 - 80 * 3 
160

== 3章 処理を学ぶ

[LIST 23-8]
if (c == 1) {
  console.log("case 1")
} else if (c == 2) {
  console.log("case 2")
} else {
  console.log("default")
  console.log("case 2")
}

[LIST 23-9]
switch (c) {
  case 1:
    console.log("case 1")
    break
  default:
    console.log("default")
  case 2:
    console.log("case 2")
}

[LIST 23-10]
let i = 0
while (i < 3) {
  const j = i * 2
  console.log(j)
  i++
}

[LIST 23-11]
for (let i = 0; i < 3; i++) {
  const j = i * 2
  console.log(j)
}

[LIST 23-12]
const pow = (n, e) => {
  let result = 1
  for (let i = 0; i < e; i++) result *= n
  return result
}
const powE = e => {
  return n => pow(n, e)
}
const sumMap = (ary, f) => {
  let result = 0
  for (let n of ary) {
    result += f(n)
  }
  return result
}

[LIST 23-13]
sumMap([1, 4, 5], powE(2))

[LIST 23-14]
> const func = () => { 
    try { 
      try { 
        throw Error("[例外1]") 
      } catch ({message}) { 
        throw Error(`${message}[例外処理1]`) 
      } finally { 
        throw Error("[終了処理1]") 
      } 
    } catch ({message}) { 
      throw Error(`${message}[例外処理2]`) 
    } 
  } 
  try { 
    func() 
  } catch ({message}) { 
    throw Error(`${message}[例外処理3]`) 
  } 
Uncaught Error: [終了処理1][例外処理2][例外処理3]
    at <anonymous>:17:9
(anonymous) @ VM1411:17

[LIST 23-15]
if (exists(egg)) {
  buyMilk(6)
} else {
  buyMilk(1)
}

== 4章 オブジェクトを学ぶ

[LIST 23-16]
> class User { 
    constructor(id, name) { 
      this.id = id 
      this.name = name 
    } 

    post() { 
      console.log(`post by ${this.name}`) 
    } 
  } 

  class Administrator extends User { 
    publish() { 
      console.log(`publish by ${this.name}`) 
    } 
  } 

[LIST 23-17]
> let admin = new Administrator(999, "管理者") 
undefined
> admin.post() 
post by 管理者
undefined
> admin.publish() 
publish by 管理者
undefined

[LIST 23-18]
> admin instanceof User 
true
> admin instanceof Administrator 
true

[LIST 23-19]
> let user = { 
    post() { 
      console.log(`post by ${this.name}`) 
    } 
  } 
  let administrator = { 
    __proto__: user, 
    publish() { 
      console.log(`publish by ${this.name}`) 
    } 
  } 

[LIST 23-20]
> administrator.id = 999 
999
> administrator.name = "管理者" 
"管理者"
> administrator.post() 
post by 管理者
undefined
> administrator.publish() 
publish by 管理者
undefined

== 5章 モジュールを学ぶ

[LIST 23-21]
class Klass {}
export { Klass as K }

[LIST 23-22]
import { K as Klass } from "./module.js"

== 6章 基本的な標準オブジェクトを学ぶ

[LIST 23-23]
> 80.7 - 10.6 
70.10000000000001

[LIST 23-24]
> Number.MAX_VALUE + Number.MAX_VALUE - Number.MAX_VALUE 
Infinity
> -Number.MAX_VALUE + Number.MAX_VALUE + Number.MAX_VALUE 
1.7976931348623157e+308

[LIST 23-25]
> typeof NaN 
"number"

[LIST 23-26]
> const re = /<([^/ !>]+)/g 
  const html = ` 
    <html lang="ja"> 
      <head><!-- 頭 --></head> 
      <body class="dark">体</body> 
    </html> 
  `; 
  [...html.matchAll(re)].map(ary => ary[1]) 
(3) ["html", "head", "body"]

== 7章 コレクションを学ぶ

[LIST 23-27]
> [1, 4, 5].map(n => n * n).reduce((sum, n) => sum += n) 
42

[LIST 23-28]
> let map = new Map([["k1", "v1"]]) 
  map.k1 = "v2" 
  console.log(map["k1"]) 
v2

[LIST 23-29]
> let days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] 
undefined
> [...new Set(days)] 
(3) [31, 28, 30]

[LIST 23-30]
> function* fibonacci() { 
    let n0 = -1 
    let n1 = 1 
    while (true) { 
      [n0, n1] = [n1, n0 + n1] 
      yield n1 
    } 
  } 

[LIST 23-31]
> let result = [] 
  let count = 10 
  for (let n of fibonacci()) { 
    result.push(n) 
    if (--count === 0) break 
  } 
  result 
(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

== 8章 複雑なデータの扱いを学ぶ

[LIST 23-32]
> let binary = new Int32Array([-570238871, -1738642577]).buffer 
  let i16 = new Int16Array(binary) 
  String.fromCharCode(...i16) 
"𪘂歯類"

[LIST 23-33]
> const deepCopy = obj => { 
    let dup 
    if (Array.isArray(obj)) { 
      dup = obj.map(e => deepCopy(e)) 
    } else if (typeof obj === "object") { 
      dup = {} 
      for (let [k, v] of Object.entries(obj)) { 
        dup[k] = deepCopy(v)  
      } 
    } else { 
      dup = obj 
    } 
    return dup 
  } 

[LIST 23-34]
> let ko1 = {id: 1, name: "Echoes", parameters: [ 
    {power: "E", speed: "E", range: "B"}, 
    {power: "C", speed: "D", range: "B"}, 
    {power: "B", speed: "B", range: "C"}, 
  ]} 
undefined
> let ko2 = deepCopy(ko1) 
undefined
> ko2 
{id: 1, name: "Echoes", parameters: Array(3)}
> ko2.parameters[0].power = "A" 
"A"
> ko1.parameters[0].power 
"E"

== 9章 国際化を学ぶ

[LIST 23-35]
> let neroBirthday = new Date(0, 11, 15) 
  neroBirthday.setFullYear(37) 
  neroBirthday 
Tue Dec 15 0037 00:00:00 GMT+0918 (日本標準時)

[LIST 23-36]
> let kiraBirthday = new Date("1966-01-30T00:00:00+09:00") 
  let opts = { 
    timeZone:"UTC",  
    year:"numeric", month:"numeric", day:"numeric", 
    hour:"numeric", minute:"numeric" 
  } 
  let df = new Intl.DateTimeFormat("en-GB", opts) 
  df.format(kiraBirthday) 
"29/01/1966, 15:00"

[LIST 23-37]
> date = new Date(-999, 0, 1) 
Thu Jan 01 -0999 00:00:00 GMT+0918 (日本標準時)
> new Intl.DateTimeFormat("en", {era:"short", year:"numeric"}).format(date) 
"1000 BC"

== 10章 非同期処理を学ぶ

[LIST 23-38]
> Promise.resolve(42) 
    .then(() => console.log("FIRST")) 
    .catch(() => console.log("first catch")) 
    .then(() => console.log("SECOND")) 
    .then(() => { 
        console.log("FIRST ERROR") 
        return Promise.reject() 
    }) 
    .then(() => "third") 
    .then(() => console.log("fourth")) 
    .catch(() => console.log("SECOND CATCH")) 
    .then(() => console.log("FIFTH")) 
    .catch(() => console.log("third catch")) 
    .finally(() => console.log("FIRST FINALLY")) 
FIRST
SECOND
FIRST ERROR
SECOND CATCH
FIFTH
FIRST FINALLY
Promise {<fulfilled>: undefined}

== 11章 メタプログラミングを学ぶ

[LIST 23-39]
> let extendNumber = num => new Proxy(Object(num), { 
    get(target, propertyKey) { 
      if (propertyKey in target) { 
        const prop = Reflect.get(target, propertyKey) 
        if (typeof prop === "function") { 
          return prop.bind(target) 
        } else { 
          return prop 
        } 
      } else if (propertyKey in Math) { 
        return (...args) => Math[propertyKey](target, ...args) 
      } 
      return undefined 
    } 
  }) 
  let en = extendNumber(3.14) 
undefined
> en.round() 
3
> en.ceil() 
4
> en.pow(2) 
9.8596
> en.toString() 
"3.14"

== 12章 Webを学ぶ

[LIST 23-40]
> document.getElementsByTagName("img") 
HTMLCollection(3) [img.gb_4b.gb_kb, img#logo-doodle-image, ...]

[LIST 23-41]
> document.getElementsByTagName("img")[1] 
<img id="logo-doodle-image" tabindex="-1" title="過去の人気Doodleゲームで楽しく家で過ごそう" src="data:image/png;base64,iVBOR…U3Q/bPj6eAAAAABJRU5ErkJggg==">

[LIST 23-42]
> document.getElementsByTagName("img")["logo-doodle-image"] 
<img id="logo-doodle-image" tabindex="-1" title="過去の人気Doodleゲームで楽しく家で過ごそう" src="data:image/png;base64,iVBOR…U3Q/bPj6eAAAAABJRU5ErkJggg==">

[LIST 23-43]
> document.getElementsByTagName("img")[1].style.border = "1px solid black" 
"1px solid black"

[LIST 23-44]
> const rule = "#logo-doodle-image {border:1px solid black}" 
  document.styleSheets[0].insertRule(rule) 

[LIST 23-45]
document.styleSheets[0].insertRule(`
  .dot {
    position:absolute; 
    width:5px;
    height:5px;
    background-color:black;
  }
`)

[LIST 23-46]
> let clicking  
  document.body.addEventListener("mousedown", () => clicking = true) 
  document.body.addEventListener("mouseup", () => clicking = false) 
  document.body.addEventListener("mousemove", evt => { 
    if (!(clicking && evt.shiftKey)) return 
    const dot = document.createElement("div") 
    dot.className = "dot" 
    dot.style.left = `${evt.clientX}px` 
    dot.style.top = `${evt.clientY}px` 
    document.body.append(dot) 
  }) 

== 13章 ネットワークを学ぶ

[LIST 23-47]
> fetch("https://jsonplaceholder.typicode.com/posts/1/comments") 
    .then(response => response.json()) 
    .then(json => console.log(json)) 
Promise {<pending>}
(5) [{…}, {…}, {…}, {…}, {…}]
  0: {postId: 1, id: 1, name: "id labore ex et quam laborum", ema...
  1: {postId: 1, id: 2, name: "quo vero reiciendis velit similiqu...
  2: {postId: 1, id: 3, name: "odio adipisci rerum aut animi", em...
  3: {postId: 1, id: 4, name: "alias odio sit", email: "Lew@alysh...
  4: {postId: 1, id: 5, name: "vero eaque aliquid doloribus et cu...
  length: 5
  __proto__: Array(0)

[LIST 23-48]
> fetch("https://jsonplaceholder.typicode.com/posts/1", { 
    method: "PATCH", 
    body: JSON.stringify({body:"Wryyy"}), 
    headers: { 
      "Content-type": "application/json" 
    } 
  }).then(response => response.json()).then(json => console.log(json)) 
Promise {<pending>}
{userId: 1, id: 1, title: "sunt ...", body: "Wryyy"}

== 14章 ストレージを学ぶ

[LIST 23-49]
> localStorage.setItem("key", "value") 
undefined
> sessionStorage.setItem("key", "value") 
undefined

[LIST 23-50]
> let openReq = indexedDB.open("todoapp", 1) 
  openReq.addEventListener("upgradeneeded", evt => { 
    const db = evt.target.result 
    const todos = db.createObjectStore("todos", 
      {keyPath: "id", autoIncrement:true}) 
    todos.createIndex("doneIndex", "done") 
  }) 
  openReq.addEventListener("success", evt => { 
    const db = evt.target.result 
    const transaction = db.transaction("todos", "readwrite") 
    const todos = transaction.objectStore("todos") 
    todos.add({text:"前書きを書く", done:true}) 
    todos.add({text:"練習問題を作成する", done:false}) 
  }) 

== 15章 マルチメディアを学ぶ

[LIST 23-51]
> let img = new Image(250, 150) 
  img.src = "./JavaScript-logo.png" 
"./JavaScript-logo.png"
> img.addEventListener("load", evt => console.log( 
    img.width, img.height, img.naturalWidth, img.naturalHeight)) 
undefined

[LIST 23-52]
> let img = document.getElementById("image") 
  let ctx = document.getElementById("canvas").getContext("2d") 
  ctx.drawImage(img, 0, 0) 
  let imageData1 = ctx.getImageData(0, 0, 200, 200) 
  let imageData2 = ctx.getImageData(0, 0, 200, 200) 

  const d = 5 
  for (let y = d; y < 200-d; y += 1) { 
    for (let x = d; x < 200-d; x += 1) { 
      let [ar, ag, ab] = [0, 0, 0] 
      for (let dy = -d; dy < d; dy++) { 
        for (let dx = -d; dx < d; dx++) { 
          const r = imageData1.data[(y+dy)*200*4 + (x+dx)*4] 
          const g = imageData1.data[(y+dy)*200*4 + (x+dx)*4+1] 
          const b = imageData1.data[(y+dy)*200*4 + (x+dx)*4+2] 
          ar += r 
          ag += g 
          ab += b 
        } 
      } 
      imageData2.data[y*200*4 + x*4] = Math.floor(ar / Math.pow(2*d, 2)) 
      imageData2.data[y*200*4 + x*4+1] = Math.floor(ag / Math.pow(2*d, 2)) 
      imageData2.data[y*200*4 + x*4+2] = Math.floor(ab / Math.pow(2*d, 2)) 
    } 
  } 
  ctx.putImageData(imageData2, 0, 0) 

[LIST 23-53]
> // 元のcanvasと同じ大きさのOffscreenCanvasを作成し、GLコンテキストを取得 
  let canvas = document.getElementById("canvas") 
  let offscreen = new OffscreenCanvas(canvas.width, canvas.height) 
  const gl = offscreen.getContext("webgl") 

  // 以下、drawArrays()までは本文で使用したWebGL例と同じです 
  const vertices = [-0.5, 0.5, -0.5, -0.5, 0.5, -0.5] 
  const vertexBuffer = gl.createBuffer() 
  // ...省略... 
  gl.viewport(0, 0, canvas.width, canvas.height) 
  gl.drawArrays(gl.TRIANGLES, 0, 3) 

  // OffscreenCanvasの描画結果を転送 
  let ctx = canvas.getContext("bitmaprenderer") 
  ctx.transferFromImageBitmap(offscreen.transferToImageBitmap()) 

[LIST 23-54]
> let audioContext = new AudioContext() 
  fetch("./bulbul.mp3").then(resp => { 
    return resp.arrayBuffer() 
  }).then(buffer => { 
    return audioContext.decodeAudioData(buffer) 
  }).then(buffer => { 
    // ノード作成 
    const source = audioContext.createBufferSource() 
    source.buffer = buffer 
    let filter = audioContext.createBiquadFilter() 
    filter.type = "lowpass" 
    filter.frequency.value = 500 
    let analyser = audioContext.createAnalyser() 
    analyser.fftSize = 256 

    // オーディオグラフ構築 
    source.connect(filter).connect(analyser).connect( 
      audioContext.destination) 

    // 描画関数定義（本文と同じ） 
    let bufferLength = analyser.frequencyBinCount 
    let dataArray = new Uint8Array(bufferLength) 
    let height = 200 
    let ctx = document.getElementById("canvas").getContext("2d") 
    let imageData = ctx.getImageData(0, 0, bufferLength, height) 
    let count = 0 
    let draw = () => { 
      analyser.getByteFrequencyData(dataArray) 
      for (let i = 0; i < dataArray.length; i++) { 
        imageData.data[4*(128*count + i)] = dataArray[i] 
        imageData.data[4*(128*count + i) + 1] = dataArray[i] 
        imageData.data[4*(128*count + i) + 2] = dataArray[i] 
        imageData.data[4*(128*count + i) + 3] = 255 
      } 
      if (count < height) { 
        count++ 
        requestAnimationFrame(draw) 
      } else { 
        ctx.putImageData(imageData, 0, 0) 
      } 
    } 

    // 再生して結果を描画 
    source.start(0, 0, 4) 
    draw() 
  }) 

== 16章 センサーとデバイスを学ぶ

[LIST 23-55]
> for (let propName of Object.getOwnPropertyNames(window)) { 
    const prop = window[propName] 
    if (Sensor.isPrototypeOf(prop)) { 
      console.log(propName) 
    } 
  } 
AbsoluteOrientationSensor
Accelerometer
Gyroscope
LinearAccelerationSensor
OrientationSensor
RelativeOrientationSensor

== 17章 PWAを学ぶ

== 18章 セキュリティを学ぶ

== 19章 パフォーマンスを学ぶ

[LIST 23-56]
> let canvas = document.getElementById("canvas") 
  let offscreen = canvas.transferControlToOffscreen() 
  let worker7 = new Worker("js/worker7.js") 
  worker7.postMessage({canvas:offscreen}, [offscreen]) 

[LIST 23-57]
const drawBird = (scale, dx, dy) => {
  ctx.clearRect(0, 0, 200, 200)
  ctx.beginPath()
  ctx.moveTo(50*scale+dx, 50*scale+dy)
  // ...省略...
  ctx.arc(80*scale+dx, 50*scale+dy, 10*scale, 0, 2 * Math.PI)
  ctx.rect(10*scale+dx, 85*scale+dy, 40*scale, 5*scale)
  ctx.fill()
}

const moveBird = timestamp => {
  const angle = (timestamp / 20 % 360) / 180 * Math.PI
  const scale = 0.3
  const dx = 70 + 70 * Math.cos(angle*2)
  const dy = 70 + 70 * Math.sin(angle*5)
  drawBird(scale, dx, dy)

  requestAnimationFrame(moveBird)
}

let ctx
self.addEventListener("message", evt => {
  ctx = evt.data.canvas.getContext("2d")
  requestAnimationFrame(moveBird)
})

== 20章 学び続けるために
